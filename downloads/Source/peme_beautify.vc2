*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="peme_beautify.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS basebeautify AS basecustom OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: addwhitespace
		*m: countcharacterwidth
		*m: countparens
		*m: findbeforeas		&& Returns portion of the line that precedes AS
		*m: fixascolumn
		*m: fixsemicoloncolumn
		*m: getcontinuationchar
		*m: getindent
		*m: lastcharin
		*m: trimleadingwhitespace
		*m: trimtrailingwhitespace
	*</DefinedPropArrayMethod>

	Name = "basebeautify"
	
	PROCEDURE addwhitespace
		Lparameters lcLine, lnDestColumn
		
		Local laLines(1), llOneAdded, lnColumn, lnI, lnLineCount, lnWithTabs 
		
		lcLine = This.TrimTrailingWhiteSpace (lcLine)
		lnColumn = This.CountCharacterWidth (lcLine)
		
		Do While lnColumn < lnDestColumn - 1
			llOneAdded = .T.
			lnWithTabs = lnColumn + This.nTabWidth - lnColumn % This.nTabWidth
			If This.oPrefs.lUseTabs and lnWithTabs < lnDestColumn
				lcLine = lcLine + Tab
				lnColumn = lnWithTabs
			Else
				lcLine = lcLine + ' '
				lnColumn = lnColumn + 1
			Endif
		Enddo
		
		Return lcLine + IIF (llOneAdded, '', ' ')
		
		
	ENDPROC

	PROCEDURE countcharacterwidth
		Lparameters lcLine
		
		Local laLines(1), lnColumn, lnI, lnLineCount
		
		*** JRN 2010-06-08 : adding a single character at end so trailing tab is not ignored
		lnLineCount = Alines (laLines, lcLine + '?', .F., Tab)
		lnColumn = 0
		
		For lnI = 1 To lnLineCount
			lnColumn = lnColumn + Len (laLines (lnI))
			If lnI < lnLineCount
				lnColumn = lnColumn + This.nTabWidth - lnColumn % This.nTabWidth
			Endif
		Endfor
		
		Return lnColumn - 1
	ENDPROC

	PROCEDURE countparens
		Lparameters lcLine
		
		* Returns incremental count of parenthesis within this line ...
		*   add one for each left paren, subtract one for each right paren
		
		Local lcRestLineString, lcThisChar, lnCharPos, lnCharscount, lnClosingCharPosition, lnResult 
		
		lnResult = 0
		lnCharscount = Len (lcLine)
		For lnCharPos = 1 To lnCharscount
		
			lcThisChar = Substr (lcLine, lnCharPos, 1)
		
			Do Case
		
				Case lcThisChar = ['] Or lcThisChar = ["] Or						;
						(lcThisChar = '[' And Not This.IsNameChar (Right (This.TrimTrailingWhiteSpace (Left (lcLine, lnCharPos - 1)), 1)))
					* Grab entire character string
					lcRestLineString = Substr (lcLine, lnCharPos + 1)
					lnClosingCharPosition = At (IIf (lcThisChar = '[', ']', lcThisChar), lcRestLineString)
					lnCharPos = lnCharPos + lnClosingCharPosition
		
				Case Substr (lcLine, lnCharPos, 2) = INLINECOMMENTS
					Exit
		
				Case lcThisChar $ '(['
					lnResult = lnResult + 1
		
				Case lcThisChar $ '])'
					lnResult = lnResult - 1
		
			Endcase
		
		Endfor
		
		Return lnResult
		
		
	ENDPROC

	PROCEDURE findbeforeas		&& Returns portion of the line that precedes AS
		Lparameters lcLine
		Local lcLeft, lcRight, lnCounter, lnPos
		
		For lnCounter = 1 To 1000
			lnPos = Rat ('AS', Upper (lcLine), lnCounter)
			Do Case
				Case lnPos <= 1
					Return ''
				Case Substr (lcLine, lnPos - 1, 1) $ BLANKS + ')' And Substr (lcLine, lnPos + 2, 1) ISABLANK
					lcLeft = Left (lcLine, lnPos - 1)
					lcRight = Substr (lcLine, lnPos)
					If INLINECOMMENTS $ lcRight
						lcRight = Left (lcRight, At (INLINECOMMENTS, lcRight) - 1)
					Else
						lcRight = lcRight
					Endif
		
					If Not (')' $ lcRight Or '(' $ lcRight Or '.' $ lcRight)
						Return lcLeft
					Endif
			Endcase
		Endfor
		
	ENDPROC

	PROCEDURE fixascolumn
		Lparameters lcLine, lnDestColumn
		Local lcLeft, lcRight, lcRightNoComments
		
		lcLeft = This.FindBeforeAS (lcLine)
		If 0 = Len (lcLeft)
			Return lcLine
		Endif
		
		lcRight = Substr (lcLine, 1 + Len (lcLeft))
		If Not Right (lcLine,1) ISABLANK
			lcLine = lcLine + ' '
		Endif
		
		Return This.AddWhiteSpace (lcLeft, lnDestColumn) + lcRight
		
	ENDPROC

	PROCEDURE fixsemicoloncolumn
		Lparameters lcLine, lnDestColumn
		Local lcExecutable, lcRight, lnEOL 
		
		lnEOL = Evl (At (INLINECOMMENTS, lcLine), Len (lcLine) + 1)
		lcExecutable = This.TrimTrailingWhiteSpace (Left (lcLine, lnEOL - 1))
		If Right (lcExecutable, 1) # ';'
			Return lcLine
		Endif
		
		lcRight = Substr (lcLine, Len (lcExecutable))
		lcLine = Left (lcLine, Len (lcExecutable) - 1)
		lcLine = This.AddWhiteSpace (lcLine, lnDestColumn)
		Return lcLine + lcRight
		
	ENDPROC

	PROCEDURE getcontinuationchar
		Lparameters lcLine, llComment
		* Returns:
		* 	' ' for no continuation
		*	';' for continuation of a code line
		*	'*' for continuation of a comment line
		Local lnPos 
		
		Do Case
			Case Right (This.TrimTrailingWhiteSpace (lcLine), 1) = ';'
				If llComment Or Getwordnum (lcLine,1) = '*' Or ('&' + '&') $ lcLine
					Return '*'
				Else
					Return ';'
				Endif
			Case  ('&' + '&') $ lcLine
				lnPos = At (('&' + '&'), lcLine)
				lcLine = Left (lcLine, lnPos - 1)
				If Right (This.TrimTrailingWhiteSpace (lcLine), 1) = ';'
					Return ';'
				Else
					Return ' '
				Endif
			Otherwise
				Return ' '
		Endcase
		
	ENDPROC

	PROCEDURE getindent
		Lparameters lcline
		Local lcChar, lcIndent, lnI
		
		lcIndent = ''
		For lnI = 1 To Len (lcline)
			lcChar = Substr (lcline, lnI, 1)
			If lcChar ISABLANK
				lcIndent = lcIndent + lcChar
			Else
				Exit
			Endif
		Endfor
		
		Return lcIndent
		
	ENDPROC

	PROCEDURE isnamechar
		Lparameters lcChar
		
		Return Isalpha (lcChar) Or Isdigit (lcChar) Or lcChar = '_'
		
	ENDPROC

	PROCEDURE lastcharin
		Lparameters lcLine
		* returns last character, other then whitespace or semi-colon
		Local lcRight, lnPos
		If INLINECOMMENTS $ lcLine
			lnPos = At (INLINECOMMENTS, lcLine)
			lcLine = Left (lcLine, lnPos - 1)
		Endif
		
		lcLine = This.TrimTrailingWhiteSpace (lcLine)
		lcRight = Right (lcLine, 1)
		If lcRight = ';'
			lcRight = Right (This.TrimTrailingWhiteSpace (Left (lcLine, Len (lcLine) - 1)), 1)
		Endif
		
		Return lcRight
		
	ENDPROC

	PROCEDURE trimleadingwhitespace
		Lparameters lcText
		
		Do While Left (lcText, 1) ISABLANK
			lcText = Right (lcText, Len (lcText) -1)
		Enddo
		
		Return lcText
		
	ENDPROC

	PROCEDURE trimtrailingwhitespace
		Lparameters lcText
		
		Do While Right (lcText, 1) ISABLANK
			lcText = Left (lcText, Len (lcText) -1)
		Enddo
		
		Return lcText
		
	ENDPROC

ENDDEFINE

DEFINE CLASS beautify AS basebeautify OF "peme_beautify.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: addasphase
		*m: addnewlocal
		*m: addobjectidlist
		*m: alignsemicolons
		*m: atnew
		*m: beautifycodeblock
		*m: beautifyinsertcode
		*m: beautifyreplacecode
		*m: beautifyselectcode
		*m: beautifyselectcreatebreakpoints
		*m: beautifyselectmain
		*m: beautifyselectstandard
		*m: beautifyselectx
		*m: beautifysingleline
		*m: beautifyword
		*m: calccolumn
		*m: calccolumnoffset		&& Given a starting column, offsets it; primarily for handling tabs
		*m: converttabsforindent
		*m: createidlist
		*m: createidlistcursors
		*m: createidlistsummary
		*m: createlocalsforcodeblock
		*m: createlocalstatements
		*m: createnewlocals
		*m: doformidlist
		*m: doidlisttext
		*m: dolocals
		*m: fetchparameterslist
		*m: findcurrentlocals
		*m: findlocalslinenumber
		*m: findprocstartline
		*m: fixwith
		*m: fixwithstatements
		*m: formatidlist
		*m: getassignmentcol
		*m: getconstants
		*m: geteditorwindowtext
		*m: getindentation
		*m: getparameterslist
		*m: getsourcecodeline
		*m: getvariableslist
		*m: getwindowhandle
		*m: insertconstants
		*m: insertid
		*m: insertidothers
		*m: insertlocalids
		*m: iskeyword
		*m: movelocalstotop
		*m: nativebeautify
		*m: parsecodeline
		*m: parselineforidlist
		*m: parseprgcodeblocks
		*m: peme_beautify
		*m: peme_createidlist
		*m: peme_createlocals
		*m: peme_createobjectidlist
		*m: regexpsearch
		*m: removeparens
		*m: setbeautifyoptions
		*m: whereis
		*p: cbeautifyoptions
		*p: ccurrentlocals
		*p: ccurrentwithendwith
		*p: clocalsplugin
		*p: clocalstatement
		*p: cpluginbeautifyselect
		*p: cpluginisoperator
		*p: csystemmemoryvariables
		*p: laddmdots
		*p: laddtockl
		*p: lapplyckl
		*p: lautoaddtockl
		*p: lfieldreference
		*p: lnodotsinassignments
		*p: lreturns
		*p: ltestselect
		*p: nafterwithcolumn
		*p: nbeautifyselectiontype
		*p: ncharsafterset
		*p: nlocalslist
		*p: nmdotsusage
		*p: nnewlocalscount
		*p: nselend
		*p: nselstart
		*p: ntabwidth
		*p: nwithendwithlevel
		*p: oeditorwin
		*p: onativebeautify
		*p: oprefs
		*p: oregexp
		*p: outils
		*a: acodelines[1,0]
		*a: alocalslist[1,0]
		*a: anewlocals[1,0]
		*a: aprgcodeblocks[1,0]
		*a: awithendwith[1,0]
		*a: nbeautifyoptions[9,0]
	*</DefinedPropArrayMethod>

	HIDDEN Height,HelpContextID,Init
	cbeautifyoptions = 
	ccurrentlocals = 
	ccurrentwithendwith = .F.
	clocalsplugin = 
	clocalstatement = 
	cpluginbeautifyselect = 
	cpluginisoperator = 
	csystemmemoryvariables = 
	laddmdots = .F.
	laddtockl = .F.
	lapplyckl = .F.
	lautoaddtockl = .F.
	lfieldreference = .F.
	lnodotsinassignments = .F.
	lreturns = .F.
	ltestselect = .F.
	nafterwithcolumn = 0
	Name = "beautify"
	nbeautifyselectiontype = 2
	ncharsafterset = .F.
	nlocalslist = 
	nmdotsusage = 0
	nnewlocalscount = 0
	nselend = 0
	nselstart = 0
	ntabwidth = 1
	nwithendwithlevel = 0
	oeditorwin = .NULL.
	onativebeautify = .NULL.
	oprefs = .NULL.
	oregexp = .F.
	outils = .NULL.
	_memberdata = <VFPData>
		<memberdata name="onativebeautify" display="oNativeBeautify"/>
		<memberdata name="oprefs" display="oPrefs"/>
		<memberdata name="oeditorwin" display="oEditorWin"/>
		<memberdata name="outils" display="oUtils"/>
		<memberdata name="geteditorwindowtext" display="GetEditorWindowText"/>
		<memberdata name="nselstart" display="nSelStart"/>
		<memberdata name="nselend" display="nSelEnd"/>
		<memberdata name="getparameterslist" display="GetParametersList"/>
		<memberdata name="getidlist" display="GetIDList"/>
		<memberdata name="idlistsetup" display="IDListSetup"/>
		<memberdata name="parselineforidlist" display="ParseLineForIDList"/>
		<memberdata name="insertidothers" display="InsertIDOthers"/>
		<memberdata name="createidlistsummary" display="CreateIDListSummary"/>
		<memberdata name="createidlistcursors" display="CreateIDListCursors"/>
		<memberdata name="insertid" display="InsertID"/>
		<memberdata name="peme_createidlist" display="PEME_CreateIDList"/>
		<memberdata name="createidlist" display="CreateIDList"/>
		<memberdata name="lfieldreference" display="lFieldReference"/>
		<memberdata name="insertconstants" display="InsertConstants"/>
		<memberdata name="getconstants" display="GetConstants"/>
		<memberdata name="peme_createobjectidlist" display="PEME_CreateObjectIDList"/>
		<memberdata name="doformidlist" display="DoFormIDList"/>
		<memberdata name="addobjectidlist" display="AddObjectIDList"/>
		<memberdata name="insertlocalids" display="InsertLocalIDs"/>
		<memberdata name="getprocedurestartpositions" display="GetProcedureStartPositions"/>
		<memberdata name="converttabsforindent" display="ConvertTabsForIndent"/>
		<memberdata name="doidlisttext" display="DoIDListText"/>
		<memberdata name="laddmdots" display="lAddMDots"/>
		<memberdata name="nmdotsusage" display="nMDotsUsage"/>
		<memberdata name="lreturns" display="lRETURNS"/>
		<memberdata name="beautifyword" display="BeautifyWord"/>
		<memberdata name="lapplyckl" display="lApplyCKL"/>
		<memberdata name="laddtockl" display="lAddtoCKL"/>
		<memberdata name="lautoaddtockl" display="lAutoAddtoCKL"/>
		</VFPData>
	
	PROCEDURE addasphase
		Lparameters lcName, lcASPhrase
		Local lcSuffix, lcVartype 
		
		lcVartype = Upper(Substr(lcName, 2, 1))
		
		Do Case
			Case Not Empty (lcASPhrase)
				Return lcName + ' as ' + lcASPhrase
			Case lcName # 'l'
				Return lcName
			Case lcVartype = "N"
				lcSuffix = " as Number"
			Case lcVartype = "I"
				lcSuffix = " as Integer"
			Case lcVartype = "O"
				lcSuffix = " as Object"
			Case lcVartype = "L"
				lcSuffix = " as Boolean"
			Case lcVartype = "C"
				lcSuffix = " as String"
			Case lcVartype = "U"
				lcSuffix = " as Variant"
			Case lcVartype = "D"
				lcSuffix = " as Date"
			Case lcVartype = "T"
				lcSuffix = " as DateTime"
			Case lcVartype = "Y"
				lcSuffix = " as Currency"
			Otherwise
				lcSuffix = ''
		EndCase
		
		Return lcName + lcSuffix
		
	ENDPROC

	PROCEDURE addnewlocal
		Lparameters lcNewLocalName, lcASphrase, llArray, llAlreadyLocal, lcArrayDims
		Local lcName, lnRow
		
		lcName = Alltrim (lcNewLocalName)
		* Remove array dimensions
		Do Case
			Case '&' $ lcName
				Return
			Case '(' $ lcName
				lcName = Left (lcName, At ('(', lcName) - 1)
				llArray = .T.
			Case '[' $ lcName
				lcName = Left (lcName, At ('[', lcName) - 1)
				llArray = .T.
			Case ['] $ lcName or ["] $ lcName
				lcName = Chrtran(lcName, ['"], '') 
		Endcase
		
		If Lower (Left (lcName, 2)) = 'm.'
			lcName = Substr (lcName,3)
		Endif
		
		If '.' $ lcName and This.lNoDotsInAssignments 
			Return
		Endif
		
		Do Case
		
			Case Empty (lcName)
		
			Case lcName = '_'  and  (Upper (lcName) + '_') $ This.cSystemMemoryVariables
		
			Case (',' + Lower (lcName) + ',') $ Lower (This.cCurrentLocals)
		
			Case This.nNewLocalsCount > 0  And Ascan (This.aNewLocals, lcName, -1, -1, 1, 15) # 0
				lnRow = Ascan (This.aNewLocals, lcName, -1, -1, 1, 15)
				This.aNewLocals (lnRow,8) = .T.
				If llArray And llAlreadyLocal
					This.aNewLocals (lnRow,3) = llArray
					This.aNewLocals (lnRow,7) = Evl (lcArrayDims, '1')
				Endif
		
			Otherwise
				lnRow = This.nNewLocalsCount + 1
				This.nNewLocalsCount = lnRow
				Dimension This.aNewLocals (lnRow, 10)
				This.aNewLocals (lnRow,1) = lcName
				This.aNewLocals (lnRow,2) = Evl (lcASphrase, ' ')
				This.aNewLocals (lnRow,3) = llArray
				This.aNewLocals (lnRow,4) = Not Empty (lcASphrase)
				This.aNewLocals (lnRow,5) = lcName = 'l'
				This.aNewLocals (lnRow,6) = llAlreadyLocal
				This.aNewLocals (lnRow,7) = Evl (lcArrayDims, '1')
		
		Endcase
		
	ENDPROC

	PROCEDURE addobjectidlist
		Lparameters loObject, llRecursive
		
		Local loControl AS Object
		Local laObjectMembers(1), lcCode, lcName, lcObjectName, lnControlCount, lnI, lNonDefault, lnRow
		
		lcObjectName = This.oUtils.GetObjectPath(loObject)
		
		Amembers(laObjectMembers, loObject, 1, 'PHG#')
		
		For lnRow = 1 To Alen(laObjectMembers, 1)
			If Inlist(laObjectMembers(lnRow,2), 'Method', 'Event')
				lNonDefault = 'C' $ laObjectMembers[lnRow, 3]
				If lNonDefault
					lcName = laObjectMembers(lnRow,1)
					lcCode = loObject.ReadMethod(lcName)
					If Not Empty(lcCode)
						This.GetConstants (lcCode)
						Insert Into crsr_IDs_Procs (ProcName, StartLine) Values (lcObjectName + '.' + lcName, 1)
						Alines (This.aCodeLines, lcCode)
						This.CreateIDList ('', 1, Alen (This.aCodeLines))
					Endif
				Endif
			Endif
		Endfor
		
		If llRecursive
			lnControlCount = This.oUtils.GetControlCount(loObject)
			If lnControlCount # 0 And "O" = Type("loObject.Objects(1)")
				For lnI = 1 To lnControlCount
					loControl = loObject.Objects(lnI)
					This.AddObjectIDList(loControl, .T.)
				Endfor
			Endif
		Endif
		
	ENDPROC

	PROCEDURE alignsemicolons
		Lparameters lcCodeBlock
		
		Local laLines[1], laPositions[1], lcLine, lnCount
		Local lcExecutable, lcResult, lcRight, lnEOL, lnI, lnMaxPosition, lnWidth
		
		lnCount = Alines (laLines, lcCodeBlock + ' ') && but we'll ignore the first line!
		Dimension laPositions (lnCount)
		lnMaxPosition = 0
		
		For lnI = 2 To lnCount
			lcLine = laLines(lnI)
			lnEOL = Evl (At (INLINECOMMENTS, lcLine), Len (lcLine) + 1)
			lcExecutable = This.TrimTrailingWhiteSpace (Left (lcLine, lnEOL - 1))
			If Right (lcExecutable, 1) # ';'
				laPositions(lnI) = -1
				Loop
			Endif
			lcLine = This.TrimTrailingWhiteSpace (Left (lcLine, Len (lcExecutable) - 1))
			lnWidth = This.CountCharacterWidth (lcLine)
			lnMaxPosition = Max(lnMaxPosition, lnWidth)
			laPositions(lnI) = Len (lcLine)
		Endfor
		
		lcResult = ''
		lnMaxPosition = Min (This.oPrefs.nSemiColoncolumn, This.CalcColumnOffset (lnMaxPosition + 1, This.oPrefs.nBeforeSemicolons))
		For lnI = 2 To lnCount
			lcLine = laLines(lnI)
			lnWidth = laPositions(lnI)
			If lnWidth >= 0
				lcRight = This.TrimLeadingWhiteSpace (Substr (lcLine, lnWidth + 1))
				lcLine = Left (lcLine, lnWidth)
				lcLine = This.AddWhiteSpace (lcLine, lnMaxPosition) + lcRight
			Endif
			lcResult = lcResult + LINEEND + This.TrimTrailingWhiteSpace (lcLine)
		Endfor
		
		Return lcResult
		
	ENDPROC

	PROCEDURE atnew
		Lparameters lcSearchfor, lcSearched, lnOccurrence
		
		Return Evl (At (lcSearchfor, lcSearched, Evl(lnOccurrence, 1)), 1 + Len (lcSearched))
		
	ENDPROC

	PROCEDURE beautifycodeblock
		Lparameters lcCodeSource
		Local laCodeSource[1], laLines2[1], laLines[1], laResultLines(1,3)
		Local lcCleanedLine, lcCode, lcContinuationBlock, lcContinuationChar, lcFirstWord, lcFW, lcIndent
		Local lcLine, lcNewCode, lcNewIndent, lcTextBlockCode, lcThisContinuationChar, lcThisIndent, lcType
		Local lnAssignmentLines, lnC, lnCol, lnCount, lnEndParenCount, lnI, lnIndent, lnIndentChange, lnJ
		Local lnLinesCount, lnOffset, lnPosition, lnResultLineCount, lnStart, lnW
		
		If This.oPrefs.lNativeBeautify
			lcCode = This.NativeBeautify (lcCodeSource)
		Else
			lcCode = lcCodeSource
		Endif
		
		If This.lAddMDots
			lcCode = ExecScript(_Screen.cThorDispatcher, 'Thor_Proc_AddMDotsMultipleProcs.PRG', lcCode, This.nMDotsUsage = 3)
		Endif
		
		If This.lApplyCKL Or This.lAddToCKL
			Local loAddWordstoCKL
			loAddWordstoCKL = Execscript(_Screen.cThorDispatcher, 'Class= clsAddWordstoCKL from Thor_Proc_AddWordsToCKL.PRG')
		
			If This.lAddToCKL
				loAddWordstoCKL.ProcessText(lcCode, .F., .T.)
				loAddWordstoCKL.PostProcessing(.F., This.lAutoAddtoCKL)
			Endif
		
			If This.lApplyCKL
				loAddWordstoCKL.CreateAllKeywordsCursor()
				lcCode = loAddWordstoCKL.ApplyCKL(lcCode)
			Endif
		
		EndIf
		
		Dimension laLines(1)
		Alines (laLines, lcCode + ' ', .F.)
		Alines (laCodeSource, lcCodeSource + ' ', .F.)
		lnLinesCount = Min (Alen (laLines), Alen (laCodeSource))
		Dimension laResultLines(lnLinesCount,3)
		lnResultLineCount = 0
		
		lcContinuationChar = ' '
		lnAssignmentLines = 0
		
		For lnCount = 1 To lnLinesCount
			lcLine = laLines[lnCount]
			lcFirstWord = Upper (Getwordnum (lcLine,1))
			lcThisContinuationChar = This.GetContinuationChar (lcLine)
		
			Do Case
		
				Case lcFirstWord == 'TEXT'
					* For Text/EndText, do nothing with initial line
					lcCleanedLine = This.BeautifySingleLine (lcLine)
					lnResultLineCount = lnResultLineCount + 1
					laResultLines (lnResultLineCount, 1) = lcCleanedLine
		
					lcTextBlockCode = ''
					Do Case
						Case '{PEME:IGNORE}' $ Upper (lcCleanedLine)
							lcType = 'Ignore'
						Case '{PEME:CODE}' $ Upper (lcCleanedLine)
							lcType = 'Code'
						Case '{PEME:SELECT}' $ Upper (lcCleanedLine)
							lcType = 'Select'
						Case This.oPrefs.lBeautifyTEXTasSelect
							For lnI = lnCount + 1 To lnLinesCount
								lcFW = Upper (Getwordnum (laLines[lnI],1))
								Do Case
									Case Empty(lcFW)
		
									Case 'SELECT ' = lcFW
										lcType = 'Select'
										Exit
									Otherwise
										lcType = 'Ignore'
										Exit
								Endcase
							Endfor
						Otherwise
							lcType = 'Ignore'
					Endcase
		
					For lnCount = lnCount + 1 To lnLinesCount
						lcLine = laLines[lnCount]
						lcFirstWord = Upper (Getwordnum (lcLine,1))
						If lcFirstWord == 'ENDTEXT'
							Exit
						Endif
						If lcType = 'Select'
							lcTextBlockCode = lcTextBlockCode + LINEEND + This.BeautifySingleLine (laLines[lnCount], This.oPrefs.cIgnoreTextOperators, .T.)
						Else
							lcTextBlockCode = lcTextBlockCode + LINEEND + laCodeSource[lnCount]
						Endif
					Endfor
		
					Do Case
						Case lcType = 'Select'
							lcTextBlockCode = LINEEND + This.BeautifySelectCode (Substr (lcTextBlockCode, 1 + Len (LINEEND)), .F., This.nTabWidth)
						Case lcType = 'Code'
							lcTextBlockCode = This.BeautifyCodeBlock (lcTextBlockCode)
						Otherwise
					Endcase
					lnResultLineCount = lnResultLineCount + 1
					laResultLines (lnResultLineCount, 1) = Substr (lcTextBlockCode, 1 + Len (LINEEND))
		
					lnResultLineCount = lnResultLineCount + 1
					laResultLines (lnResultLineCount, 1) = lcLine
					lcContinuationChar = This.GetContinuationChar (lcLine)
		
				Case lcThisContinuationChar = ' ' Or lnCount >= lnLinesCount
					* simple line, no continuation, nothing special to do.
					If Inlist (lcFirstWord, '*', INLINECOMMENTS)
						lcCleanedLine = This.GetIndent (lcLine) + This.TrimLeadingWhiteSpace (laCodeSource(lnCount))
					Else
						lcCleanedLine = This.BeautifySingleLine (lcLine)
					Endif
					lnResultLineCount = lnResultLineCount + 1
		
					laResultLines (lnResultLineCount, 1) = lcCleanedLine
					laResultLines (lnResultLineCount, 2) = This.GetAssignmentCol(lcCleanedLine)
		
				Otherwise
					****************************************************************
					* get the entire continuation block of lines
					lcIndent = This.GetIndent (lcLine)
					lnEndParenCount = 0
					lcContinuationBlock = ''
		
					Do While .T.
						If lcContinuationChar == '*' Or Inlist (lcFirstWord, '*', INLINECOMMENTS)
							* continuation lines for comments
							lcLine = This.GetIndent (lcLine) + This.TrimLeadingWhiteSpace (laCodeSource(lnCount))
							lcContinuationBlock = lcContinuationBlock + LINEEND + lcLine
							lcContinuationChar = This.GetContinuationChar (lcLine, .T.)
						Else
							* correction for continuation line after in-line comments
							If lcContinuationChar == ';'											;
									and (Not Substr (lcLine, 1 + Len (lcIndent), 1) ISABLANK)		;
									and lcLine = lcIndent											;
									and This.nBeautifyOptions (7) = 1
								lcLine = Stuff (lcLine, 1 + Len (lcIndent), 0, 						;
									IIF (This.nBeautifyOptions(4) = 1, Tab, Space (This.nBeautifyOptions(3))))
							Endif
		
							If lnEndParenCount # 0 And This.oPrefs.nParenIndent > 0
								lcThisIndent = This.GetIndent (lcLine)
								lcNewIndent = Space (lnEndParenCount * This.oPrefs.nParenIndent)
								lcNewIndent = This.ConvertTabsForIndent(lcNewIndent)
								lcLine = Stuff (lcLine, 1 + Len (lcThisIndent), 0, lcNewIndent)
							Endif
							lnEndParenCount = Max (0, lnEndParenCount + This.CountParens (lcLine))
		
							lcCleanedLine = This.BeautifySingleLine (lcLine)
							lcContinuationBlock = lcContinuationBlock + LINEEND + lcCleanedLine
							lcContinuationChar = This.GetContinuationChar (lcLine)
						Endif
		
						If lcContinuationChar # ' ' And lnCount < lnLinesCount
							lnCount = lnCount + 1
							lcLine = laLines[lnCount]
						Else
							Exit
						Endif
					Enddo
		
					****************************************************************
					Do Case
						Case (lcFirstWord == 'SELECT' Or lcFirstWord == 'UPDATE' Or lcFirstWord == 'DELETE')	;
								and This.oPrefs.nSelectIndentation = 3
							* PEME Custom indentation for SELECTs
							lcContinuationBlock = This.BeautifySelectCode (lcContinuationBlock, .T., This.nTabWidth)
		
						Case lcFirstWord == 'INSERT' 								;
								and This.oPrefs.nSelectIndentation = 3
							* PEME Custom indentation for REPLACEs
							lcContinuationBlock = This.BeautifyInsertCode (lcContinuationBlock)
		
						Case lcFirstWord == 'REPLACE' 								;
								and This.oPrefs.nReplaceIndentation = 3
							* PEME Custom indentation for REPLACEs
							lcContinuationBlock = This.BeautifyReplaceCode (lcContinuationBlock)
		
						Case This.oPrefs.lNativeBeautify And (;
								(This.oPrefs.nSelectIndentation = 2 And (lcFirstWord == 'SELECT' Or lcFirstWord == 'UPDATE' Or lcFirstWord == 'DELETE'));
								Or (This.oPrefs.nReplaceIndentation = 2 And lcFirstWord == 'REPLACE');
								)
							* Ugh.  Keep original indentation;
							* ... need to backtrack thru lines to reinstate, ;
							* but adding back the correct indentation matching the first line
							* This appears indirect at first, but correctly handles inline comments, etc
							lnC = Alines (laLines2, Substr (lcContinuationBlock, 1 + Len (LINEEND)) + ' ')
							lnOffset = lnCount - lnC
							lnIndentChange = This.CountCharacterWidth (This.GetIndent (laLines(lnOffset + 1)));
								- This.CountCharacterWidth (This.GetIndent (laCodeSource(lnOffset + 1)))
							lcContinuationBlock = ''
							For lnI = 1 To lnC
								lnIndent = lnIndentChange + This.CountCharacterWidth (This.GetIndent (laCodeSource(lnI + lnOffset)))
								If lnIndent > 0
									lcIndent = Space (lnIndent)
									lcIndent = This.ConvertTabsForIndent(lcIndent)
								Else
									lcIndent = ''
								Endif
								lcContinuationBlock = lcContinuationBlock + LINEEND + lcIndent ;
									+ This.TrimLeadingWhiteSpace (laLines2 (lnI))
							Endfor
		
					Endcase
		
					lnResultLineCount = lnResultLineCount + 1
					Do case
						Case This.oPrefs.lAlignSemicolons
							laResultLines (lnResultLineCount, 1) = Substr (This.AlignSemiColons (lcContinuationBlock), 1 + Len (LINEEND)) 
						Case lcContinuationBlock = LINEEND
							laResultLines (lnResultLineCount, 1) = Substr (lcContinuationBlock, 1 + Len (LINEEND))
						Otherwise
							laResultLines (lnResultLineCount, 1) = Substr (lcContinuationBlock, 2)
					Endcase
			Endcase
		Endfor
		
		lnStart = 0
		If This.oPrefs.lFixAssignments
			For lnI = 1 To lnResultLineCount
				lnW = laResultLines (lnI, 2)
				If 'N' = Vartype(lnW) And lnW > 0
					If lnStart = 0
						lnStart = lnI
						lnPosition = laResultLines (lnI, 2)
					Else
						lnPosition = Max (lnPosition, lnW)
						For lnJ = lnStart To lnI
							laResultLines (lnJ,3) = lnPosition
						Endfor
					Endif
				Else
					lnStart = 0
				Endif
			Endfor
		Endif
		
		lcNewCode = ''
		For lnI = 1 To lnResultLineCount
			lcLine = laResultLines (lnI, 1)
			lnCol = At('=', lcLine) - 1
			lnW = laResultLines (lnI, 3)
			If 'N' = Vartype(lnW) And lnW > 0
				lcNewCode = lcNewCode + LINEEND ;
					+ This.AddWhiteSpace(This.TrimTrailingWhiteSpace(Left (lcLine, lnCol)), lnW + 2);
					+ This.TrimLeadingWhiteSpace(Substr (lcLine, lnCol + 1))
			Else
				lcNewCode = lcNewCode + LINEEND + lcLine
			Endif
		Endfor
		
		Return Trim(Substr (lcNewCode, 1 + Len (LINEEND)), 1, ' ', Tab)
		
	ENDPROC

	PROCEDURE beautifyinsertcode
		Lparameters lcCode
		Local laLines[1], lcLine, lcResult, lnCount, lnLineCount
		
		lnLineCount = Alines (laLines, lcCode, .F.)
		lcResult = ''
		
		For lnCount = 1 To lnLineCount
			lcLine = laLines (lnCount)
		
			If Upper (Getwordnum (lcLine, 1)) == 'SELECT'
				For lnCount = lnCount + 1 To lnLineCount
					lcLine = lcLine + LINEEND + laLines (lnCount)
				Endfor
				lcLine = This.BeautifySelectCode(lcLine, .T., This.nTabWidth)
			Endif
		
			lcResult = lcResult + LINEEND + lcLine
		
		Endfor
		
		Return Substr (lcResult, 1 + Len (LINEEND))
		
	ENDPROC

	PROCEDURE beautifyreplacecode
		Lparameters lcCode
		
		Local laLines(1), laResult(1)
		Local lcCurrentKeyWord, lcFirstWord, lcIndent, lcLine, lcNewLine, lcResult, llFixWITH, ln, lnAfterWITH
		Local lnBeforeWITH, lnCount, lnEndParenCount, lnHangingIndent, lnIndent, lnIndentAll, lnLineCount
		Local lnParenCount, lnTotalIndent, lnWITHCol
		
		lnLineCount = Alines (laLines, lcCode, .F.)
		Acopy (laLines, laResult)
		lnWITHCol = 0
		
		* find first non-blank line ... it better start with SELECT!
		For lnCount = 1 To lnLineCount
			lcLine = laLines (lnCount)
			Do Case
				Case Empty (lcLine)
		
				Case Inlist (Upper (Getwordnum (lcLine, 1)) + ' ', 'REPLACE ')
					Exit
				Otherwise
					Return lcCode
			Endcase
		Endfor
		
		lnIndentAll= This.CountCharacterWidth (This.GetIndent (lcLine))
		lcCurrentKeyWord = Upper (Getwordnum (lcLine, 1))
		* determine indent to be applied to all lines
		lcResult = ''
		
		For lnCount = lnCount To lnLineCount
			lcLine = This.TrimLeadingWhiteSpace (laLines (lnCount))
			lcFirstWord = Upper (Getwordnum (lcLine, 1))
			llFixWITH	= .F.
		
			Do Case
				Case lcFirstWord == 'REPLACE'
					lnParenCount = 0
					lnEndParenCount = This.CountParens (lcLine)
					lnIndent = 0
					lnHangingIndent = This.oPrefs.nReplaceFieldIndent + This.oPrefs.nSingleREPLACEFieldIndent
					If Upper (Getwordnum (lcLine, 3)) == 'WITH'
						llFixWITH = .T.
						lcLine = This.AddWhiteSpace (Left (lcLine,7), This.oPrefs.nReplaceFieldIndent + 1) + This.TrimLeadingWhiteSpace (Substr (lcLine,8))
					Endif
		
				Case (' ' + lcFirstWord + ' ') $ ' FOR IN WHILE ' And lnParenCount = 0
					lnParenCount = 0
					lnEndParenCount = This.CountParens (lcLine)
					lnIndent = This.oPrefs.nReplaceKeywords
					lnHangingIndent = lnIndent + This.oPrefs.nReplaceHangingIndent
		
				Case (Upper (Getwordnum (lcLine, 2)) == 'WITH' Or Upper (Getwordnum (lcLine, 3)) == 'WITH') And lnParenCount = 0
					ln = 0
					lnEndParenCount = This.CountParens (lcLine)
					lnIndent = This.oPrefs.nReplaceFieldIndent - IIf (Upper (Getwordnum (lcLine, 1)) = ',', 2, 0)
					lnHangingIndent = This.oPrefs.nReplaceFieldIndent + This.oPrefs.nSingleREPLACEFieldIndent
					llFixWITH	= .T.
		
				Otherwise
					lnEndParenCount = Max (0, lnParenCount + This.CountParens (lcLine))
					lnIndent = lnHangingIndent
		
			Endcase
		
			lnTotalIndent = lnIndentAll + lnIndent + (This.oPrefs.nParenIndent * lnParenCount)
			lcIndent = Space (lnTotalIndent)
			lcNewIndent = This.ConvertTabsForIndent(lcIndent)
		
			lcNewLine = lcNewIndent + lcLine
			If llFixWITH And This.oPrefs.lAlignWith
				lnWITHCol = Max (lnWITHCol, This.CalcColumn (lcNewLine, 'WITH'))
			Endif
		
			laResult (lnCount) = lcNewLine
			lnParenCount = lnEndParenCount
		
		Endfor
		
		lcResult = ''
		lnBeforeWITH = This.CalcColumnOffset (lnWITHCol, This.oPrefs.nBeforeWith)
		lnAfterWITH = This.CalcColumnOffset (lnBeforeWITH + 3, This.oPrefs.nAfterWith)
		
		For lnCount = 1 To lnLineCount
			lcLine = laResult (lnCount)
		
			If lnWITHCol # 0
				lcNewLine = This.FixWITH (lcLine, 4, lnBeforeWITH, lnAfterWITH)
			Else
				lcNewLine = lcLine
			Endif
		
			lcResult = lcResult + LINEEND + lcNewLine
		
		Endfor
		
		Return Substr (lcResult, 1 + Len (LINEEND))
		
	ENDPROC

	PROCEDURE beautifyselectcode
		Lparameters tcCode, tlSemiColons, tnTabWidth
		Local lcCode, lcNewResult, lcResult, lnLastLen, lnTabs, lnTabWidth
		
		lnTabWidth = Evl(tnTabWidth, 1) 
		lcCode = Strtran(tcCode, Tab, Space(lnTabWidth)) 
		lcResult = This.Beautifyselectx(lcCode, tlSemiColons)
		
		* leading tabs, where approppriate
		If lnTabWidth > 1
			lnLastLen = 0
			lcNewResult = ccCR + lcResult
			lnTabs = 0
			Do While Len(lcNewResult) #lnLastLen
				lnLastLen = Len(lcNewResult)
				lcNewResult = Strtran(lcNewResult;
					, ccCR + Replicate(Tab, lnTabs) + Space(lnTabWidth);
					, ccCR + Replicate(Tab, lnTabs + 1))
				lnTabs = lnTabs + 1
			Enddo
			lcResult = Substr(lcNewResult, 2)
		Endif
		
		Return lcResult
		
	ENDPROC

	PROCEDURE beautifyselectcreatebreakpoints
		Lparameters tcText, lcAlias
		Local lcClosingChar, lcPattern, lcValue, lnFirstIndex, lnI, lnParens, loMatch, loMatches
		
		lcPattern = [('|"|] + '\[|\]|\(|\)|\&' + '\&)|\r|\,'
		loMatches = This.RegExpSearch (lcPattern, tcText)
		
		Create Cursor (lcAlias) (Start N(8), End N(8), Value c(1), nParens N(4), notcode L)
		Insert Into (lcAlias) (Start) Values (1)
		lnParens = 0
		For lnI = 1 To loMatches.Count
			loMatch		 = loMatches.Item (lnI - 1)
			lnFirstIndex = loMatch.FirstIndex
			lcValue		 = loMatch.Value
			Replace End With lnFirstIndex
			lcClosingChar = lcValue
			Do Case
				Case lcValue = '('
					lnParens = lnParens + 1
				Case lcValue = ')'
					lnParens = lnParens - 1
				Case lcValue = '['
					If This.IsNameChar (Right (Trim (Left (tcText, lnFirstIndex)), 1))
						Loop
					Endif
					lcClosingChar = ']'
				Case lcValue = ']'
					Loop
				Case lcValue = '&'
					lcClosingChar = CR
				Case lcValue = CR
					lcClosingChar = '?'
			Endcase
			Insert Into (lcAlias) (Start, Value, nParens) Values (lnFirstIndex + 1, lcValue, lnParens)
			If lcClosingChar $ ['"] + ']' + CR
				Replace notcode With .T.
				For lnI = lnI + 1 To loMatches.Count
					If loMatches.Item (lnI - 1).Value = lcClosingChar
						loMatch		 = loMatches.Item (lnI - 1)
						lnFirstIndex = loMatch.FirstIndex
						lcValue		 = loMatch.Value
						Replace End With lnFirstIndex
						Insert Into (lcAlias) (Start, Value, nParens) Values (lnFirstIndex + 1, lcValue, lnParens)
						Exit
					Endif
				Endfor
			Endif
		Endfor
		Replace End With Len (tcText)
		
	ENDPROC

	PROCEDURE beautifyselectmain
		Lparameters lcText, llSemiColons, llCommasBeginLine
		
		* A long procedure, but done this way because it recursive
		
		Local laEndParen[1], laMatch[1], laSELECTS[1], lcAlias, lcBeforeThisLine, lcBreakWords
		Local lcEndThisLine, lcNewLine, lcReplaceText, lcResultText, lcSelectText, lcSubQ, lcSubQuery
		Local lcThisLine, llAnyFound, llFromFound, lnEndChars, lnFirstIndex, lnI, lnIndent, lnOffset, lnPos
		Local lnSubQueries, loMatch, loMatches, lnLeadingBlanks
		
		* our important breakpoints
		lcAlias = Sys(2015)
		This.BeautifySelectCreateBreakPoints (lcText, lcAlias)
		
		* Our 'SELECT' subquery substitutions, if any
		lnSubQueries = 0
		llAnyFound	 = .T.
		
		Do While llAnyFound
			llAnyFound = .F.
			loMatches  = This.RegExpSearch ('\bSelect\b', lcText)
			For lnI = 1 To loMatches.Count
				loMatch		 = loMatches.Item (lnI - 1)
				lnFirstIndex = loMatch.FirstIndex
				Select  nParens								  ;
					From (lcAlias)							  ;
					Where Between (lnFirstIndex, Start, End)  ;
					And nParens > 0						  ;
					And Not notcode						  ;
					Into Array laMatch
				If _Tally > 0
					Select  Start					  ;
						From (lcAlias)				  ;
						Where Start > lnFirstIndex	  ;
						And nParens < laMatch[1]  ;
						And Not notcode			  ;
						Into Array laEndParen
					lcSelectText  = Substr (lcText, lnFirstIndex + 1, laEndParen[1] - lnFirstIndex - 1)
					lcReplaceText = '<<' + Sys(2015) + '>>'
		
					lnSubQueries  = lnSubQueries + 1
					Dimension laSELECTS (lnSubQueries, 2)
					laSELECTS (lnSubQueries, 1) = lcSelectText
					laSELECTS (lnSubQueries, 2) = lcReplaceText
		
					lcText		= Stuff (lcText, lnFirstIndex + 1, Len (lcSelectText), lcReplaceText)
					This.BeautifySelectCreateBreakPoints (lcText, lcAlias)
					llAnyFound = .T.
					Exit
				Endif
			Endfor
		Enddo && while .t.
		
		* Major keyword substitutions, as well as commas for fields
		lcResultText = lcText
		
		lcBreakWords = '\Wselect\W|\Wfrom\W|\Wwhere\W|\Wgroup by\W|\Worder by\W|\Whaving\W|\Wunion\W|\Winto\W'
		
		If This.oPrefs.lSelectExpandFields
			lcBreakWords = '\,|' + lcBreakWords
		Endif
		
		If This.oPrefs.lSelectExpandJoins
			lcBreakWords = lcBreakWords + '|\Wleft join\W|\Wleft outer join\W|\Wright join\W|\Wright outer join\W|\Wfull join\W' ;
				+ '|\Wfull outer join\W|\Winner join\W|\Wjoin\W'
		Endif
		
		If This.oPrefs.lSelectExpandOn
			lcBreakWords = lcBreakWords + '|\Won\W'
		Endif
		
		If This.oPrefs.lSelectExpandAndOr
			lcBreakWords = lcBreakWords + '|\W.and.\W|\W.or.\W|\Wand\W|\Wor\W'
		Endif
		
		loMatches	= This.RegExpSearch ('(' + lcBreakWords + ')', lcText)
		lnOffset	= 1 && because search includes leading blank character!
		lcNewLine	= Iif (llSemiColons, ';' + CR, ' ' + CR)
		llFromFound	= .F.
		
		For lnI = 1 To loMatches.Count
			loMatch		 = loMatches.Item (lnI - 1)
			lnFirstIndex = loMatch.FirstIndex
			Select  nParens								  ;
				From (lcAlias)							  ;
				Where Between (lnFirstIndex, Start, End)  ;
				And Not notcode						  ;
				Into Array laMatch
			If _Tally > 0
				lnFirstIndex = lnFirstIndex + lnOffset
				If loMatch.Value = ','
					Do Case
						Case llFromFound
		
						Case laMatch[1] # 0
							* lnFirstIndex points to the comma
		
						Case llCommasBeginLine
							lcEndThisLine = Substr (lcResultText, lnFirstIndex + 1)
							lcEndThisLine = Left (lcEndThisLine, This.AtNew (CR, lcEndThisLine) - 1)
							If Empty (lcEndThisLine) Or Left (Getwordnum (lcEndThisLine, 1), 1) $ ';*' Or Left (Getwordnum (lcEndThisLine, 1), 2) = '&' + '&'
								* lcResultText = Stuff (lcResultText, lnFirstIndex + 1, 1 + Len (lcEndThisLine), Space(1 + Len (lcEndThisLine)))
								lcResultText = Stuff (lcResultText, lnFirstIndex, 2 + Len (lcEndThisLine), Space(1 + Len (lcEndThisLine)) + ',')
							Else
								lnLeadingBlanks = Len(lcEndThisLine) - Len(Ltrim(lcEndThisLine))
								If lnLeadingBlanks # 1
									lcResultText = Stuff (lcResultText, lnFirstIndex + 1, lnLeadingBlanks, ' ')
									lnOffset	 = lnOffset + 1 - lnLeadingBlanks
								Endif
							Endif
							lcBeforeThisLine = Left (lcResultText, lnFirstIndex - 1)
							lcBeforeThisLine = Substr (lcBeforeThisLine, Rat (CR, lcBeforeThisLine) + 1)
							If Not Empty (lcBeforeThisLine)
								lcResultText = Stuff (lcResultText, lnFirstIndex, 0, lcNewLine)
								lnOffset	 = lnOffset + 2
							Endif
		
						Otherwise
							lcEndThisLine = Substr (lcResultText, lnFirstIndex + 1)
							lcEndThisLine = Left (lcEndThisLine, This.AtNew (CR, lcEndThisLine) - 1)
							If Empty (lcEndThisLine) Or Left (Getwordnum (lcEndThisLine, 1), 1) $ ';*' Or Left (Getwordnum (lcEndThisLine, 1), 2) = '&' + '&'
								* already at end of line
							Else
								lcResultText = Stuff (lcResultText, lnFirstIndex + 1, 0, lcNewLine)
								lnOffset	 = lnOffset + 2
							Endif
		
							lcBeforeThisLine = Left (lcResultText, lnFirstIndex - 1)
							lcBeforeThisLine = Substr (lcBeforeThisLine, Rat (CR, lcBeforeThisLine) + 1)
							If Empty (lcBeforeThisLine)
								lnEndChars   = Iif(llSemiColons, 2, 1)
								lcResultText = Stuff (lcResultText, lnFirstIndex - Len (lcBeforeThisLine) - lnEndChars, Len (lcBeforeThisLine) + lnEndChars, '')
								lnOffset	 = lnOffset - (Len (lcBeforeThisLine) + lnEndChars)
							Endif
					Endcase
		
				Else
					lcThisLine = Left (lcResultText, lnFirstIndex)
					lcThisLine = Substr (lcThisLine, Rat (CR, lcThisLine) + 1)
					If Not Empty (lcThisLine)
						lcEndThisLine = Substr (lcResultText, lnFirstIndex + 1)
						lcEndThisLine = Left (lcEndThisLine, This.AtNew (CR, lcEndThisLine) - 1)
						lcEndThisLine = Strtran(lcEndThisLine, Getwordnum(lcEndThisLine, 1), '')
						If Not Empty (Chrtran(lcEndThisLine, ccCR + ccLF + ccTAB + ';', Space(4)))
							lcResultText = Stuff (lcResultText, lnFirstIndex + 1, 0, lcNewLine)
							lnOffset	 = lnOffset + 2
						Endif
					Endif
					llFromFound = (llFromFound Or 'FROM' $ Upper (loMatch.Value)) And Not 'UNION' $ Upper (loMatch.Value)
				Endif
			Endif
		Endfor
		
		* Expand our SELECT subqueries, stuff 'em back in,
		*   making sure to expand leading white space.
		*   (note the assumption that there are no tabs involved!
		lcResultText = Strtran(This.BeautifySelectStandard (lcResultText), LF, '')
		For lnI = 1 To lnSubQueries
			lcSubQuery	  = This.BeautifySelectMain (laSELECTS (lnI, 1), llSemiColons, llCommasBeginLine)
			lcReplaceText = laSELECTS (lnI, 2)
			lnPos		  = At (lcReplaceText, lcResultText)
			lnIndent	  = lnPos - Rat (CR, Left (lcResultText, lnPos)) - 1
			lcSubQ		  = Strtran (Strtran(lcSubQuery, LF, ''), CR, CR + Space (lnIndent))
			lcResultText  = Stuff (lcResultText, lnPos, Len (lcReplaceText), lcSubQ)
		Endfor
		
		Return lcResultText
		
		
	ENDPROC

	PROCEDURE beautifyselectstandard
		Lparameters lcCode
		Local laLines[1], laResult[1], lcCurrentKeyWord, lcFirstWord, lcIndent, lcLine, lcNewLine, lcResult
		Local llFieldNextLineIndent, llFieldThisLineIndent, lnASCol, lnAfterAS, lnBeforeAS, lnCount
		Local lnEndParenCount, lnHangingIndent, lnIndent, lnIndentAll, lnLineCount, lnParenCount
		Local lnParentCount, lnPos, lnTotalIndent
		
		lnLineCount = Alines (laLines, lcCode + ' ', .F.)
		Acopy (laLines, laResult)
		
		* find first non-blank line ... it better start with SELECT or UPDATE!
		For lnCount = 1 To lnLineCount
			lcLine = laLines (lnCount)
			Do Case
				Case Empty (lcLine)
		
				Case Inlist (Upper (Getwordnum (lcLine, 1)) + ' ', 'SELECT ', 'UPDATE ', 'DELETE ')
					Exit
				Otherwise
					Return lcCode
			Endcase
		Endfor
		
		lnIndentAll		 = This.CountCharacterWidth (This.GetIndent (lcLine))
		lcCurrentKeyWord = Upper (Getwordnum (lcLine, 1))
		lnPos			 = At (lcCurrentKeyWord, Upper (lcLine))
		lcLine			 = Left (lcLine, lnPos + 5) + Space (Max (1, This.oPrefs.nCharsAfterSelect)) + This.TrimLeadingWhiteSpace (Substr (lcLine, lnPos + 6))
		laResult (lnCount) = lcLine
		If This.oPrefs.lAlignAS
			lnASCol = This.CountCharacterWidth (This.TrimTrailingWhiteSpace (This.FindBeforeAS (lcLine)))
		Else
			lnASCol = 0
		Endif
		*
		lnHangingIndent	= This.oPrefs.nFieldIndent
		lnParenCount	= This.CountParens (lcLine)
		llFieldNextLineIndent = lnParenCount # 0 Or (		;
			  This.LastCharIn (lcLine) # ','				;
			  And Not Inlist (Upper (Getwordnum (lcLine, Getwordcount (lcLine) - 1)), 'SELECT', 'DISTINCT'))
		
		For lnCount = lnCount + 1 To lnLineCount
			lcLine			= This.TrimLeadingWhiteSpace (laLines (lnCount))
			lcFirstWord		= Upper (Getwordnum (lcLine, 1))
			lnEndParenCount	= Max (0, lnParenCount + This.CountParens (lcLine))
		
			Do Case
				Case (' ' + lcFirstWord + ' ') $ ' FROM WHERE HAVING INTO TO ' And lnParenCount = 0
					lcCurrentKeyWord	  = lcFirstWord
					lnParentCount		  = 0
					lnEndParenCount		  = This.CountParens (lcLine)
					lnIndent			  = This.oPrefs.nKeyWordIndent
					lnHangingIndent		  = lnIndent + This.oPrefs.nHangingIndent
					llFieldThisLineIndent = .F.
					llFieldNextLineIndent = .F.
		
				Case Inlist (lcFirstWord, 'GROUP', 'ORDER') And Upper (Getwordnum (lcLine, 2)) == 'BY' And lnParenCount = 0
					lcCurrentKeyWord	  = lcFirstWord
					lnParentCount		  = 0
					lnEndParenCount		  = This.CountParens (lcLine)
					lnIndent			  = This.oPrefs.nKeyWordIndent
					lnHangingIndent		  = This.oPrefs.nFieldIndent
					llFieldThisLineIndent = .F.
					llFieldNextLineIndent = lnParenCount # 0 Or This.LastCharIn (lcLine) # ','
		
				Case (' ' + lcFirstWord + ' ') $ ' INNER OUTER JOIN LEFT RIGHT FULL ' And lnParenCount = 0
					lcCurrentKeyWord	  = lcFirstWord
					lnParentCount		  = 0
					lnEndParenCount		  = This.CountParens (lcLine)
					lnIndent			  = This.oPrefs.nJOINIndent
					lnHangingIndent		  = lnIndent + This.oPrefs.nHangingIndent
					llFieldThisLineIndent = .F.
					llFieldNextLineIndent = .F.
		
				Case (' ' + lcFirstWord + ' ') $ ' UNION ' And lnParenCount = 0
					lcCurrentKeyWord	  = lcFirstWord
					lnParentCount		  = 0
					lnEndParenCount		  = This.CountParens (lcLine)
					lnIndent			  = This.oPrefs.nUNIONIndent
					lnHangingIndent		  = lnIndent + This.oPrefs.nHangingIndent
					llFieldThisLineIndent = .F.
					llFieldNextLineIndent = .F.
		
				Case (' ' + lcFirstWord + ' ') $ ' SELECT ' And lnParenCount = 0
					lnPos  = At ('SELECT', Upper (lcLine))
					lcLine = Substr (lcLine, lnPos, 6) + Space (Max (1, This.oPrefs.nCharsAfterSelect)) + This.TrimLeadingWhiteSpace (Substr (lcLine, lnPos + 6))
		
					lcCurrentKeyWord	  = lcFirstWord
					lnParentCount		  = 0
					lnEndParenCount		  = This.CountParens (lcLine)
					lnIndent			  = This.oPrefs.nSELECTIndent
					lnHangingIndent		  = This.oPrefs.nFieldIndent
					llFieldThisLineIndent = .F.
					llFieldNextLineIndent = lnParenCount # 0 Or This.LastCharIn (lcLine) # ','
		
				Case (' ' + lcFirstWord + ' ') $ ' SET ' And lnParenCount = 0
					lnPos  = At ('SET', Upper (lcLine))
					lcLine = Substr (lcLine, lnPos, 3) + Space (Max (1, This.oPrefs.nCharsAfterSET)) + This.TrimLeadingWhiteSpace (Substr (lcLine, lnPos + 3))
		
					lcCurrentKeyWord	  = lcFirstWord
					lnParentCount		  = 0
					lnEndParenCount		  = This.CountParens (lcLine)
					lnIndent			  = This.oPrefs.nSETIndent
					lnHangingIndent		  = This.oPrefs.nSETFieldIndent
					llFieldThisLineIndent = .F.
					llFieldNextLineIndent = lnParenCount # 0 Or This.LastCharIn (lcLine) # ','
		
				Otherwise
					lnIndent = lnHangingIndent
					* additional indentation for fields defs that span multiple lines
					llFieldThisLineIndent = llFieldNextLineIndent
					llFieldNextLineIndent = Inlist (lcCurrentKeyWord + ' ', 'SELECT ', 'GROUP ', 'ORDER ', 'SET ') ;
						And (lnEndParenCount # 0 Or This.LastCharIn (lcLine) # ',')
					*** JRN 2010-05-27 : Correction for lines where leading comma means a new field
					If Inlist (lcCurrentKeyWord + ' ', 'SELECT ', 'GROUP ', 'ORDER ') And lnParenCount = 0 And lcFirstWord = ','
						llFieldThisLineIndent = .F.
						lnIndent			  = lnIndent - 2
					Endif
		
			Endcase
		
			lnTotalIndent = lnIndentAll + lnIndent														;
				+ (This.oPrefs.nParenIndent * lnParenCount)												;
				+ IIf (llFieldThisLineIndent And lcFirstWord # '&',										;
				  IIf (lcCurrentKeyWord = 'SET', This.oPrefs.nSingleSETFieldIndent, This.oPrefs.nSingleFieldIndent) ;
				  , 0)
			lcIndent = Space (lnTotalIndent)
			*	lcNewIndent = This.ConvertTabsForIndent(lcIndent)
			lcNewIndent = lcIndent
		
			lcNewLine = lcNewIndent + lcLine
		
			If This.oPrefs.lAlignAS
				lnASCol = Max (lnASCol, This.CountCharacterWidth (This.TrimTrailingWhiteSpace (This.FindBeforeAS (lcNewLine))))
			Endif
		
			laResult (lnCount) = lcNewLine
			lnParenCount = lnEndParenCount
		
		Endfor
		
		lcResult   = ''
		lnBeforeAS = This.CalcColumnOffset (lnASCol, This.oPrefs.nBeforeAS)
		lnBeforeAS = Min (lnBeforeAS, This.oPrefs.nAsColumn)
		lnAfterAS  = This.CalcColumnOffset (lnBeforeAS + 1, This.oPrefs.nAfterAS)
		
		For lnCount = 1 To lnLineCount
			lcLine = laResult (lnCount)
		
			If lnASCol # 0
				lcNewLine = This.FixASColumn (lcLine, 2, lnBeforeAS, lnAfterAS)
			Else
				lcNewLine = lcLine
			Endif
		
			lcResult = lcResult + LINEEND + This.TrimTrailingWhiteSpace (lcNewLine)
		
		Endfor
		
		Return Substr (lcResult, 1 + Len (LINEEND))
		
		
	ENDPROC

	PROCEDURE beautifyselectx
		Lparameters tcCode, tlSemiColons
		
		This.oRegExp = Createobject ('VBScript.RegExp')
		With This.oRegExp
			.IgnoreCase	= .T.
			.Global		= .T.
			.MultiLine	= .T.
		Endwith
		
		* we lie about tabs throughout this
		lnTabWidth = This.ntabwidth
		This.ntabwidth = 1000
		
		lcCode = Strtran (tcCode, LF, '')
		lcResult = This.BeautifySelectMain (lcCode, tlSemiColons, This.oPrefs.lSelectCommasBeginLine)
		
		This.ntabwidth = lnTabWidth
		
		Return lcResult
		
	ENDPROC

	PROCEDURE beautifysingleline
		Lparameters tcCode, tcIgnoreTextOperators, tlTextMerge
		
		Local lcCharsToAdd, lcCode, lcCommaOperators, lcNextChar, lcNot, lcOperators, lcPrevChar
		Local lcRestLineString, lcResult, lcStringConstant, lcThisChar, lnCharPos, lnCharscount
		Local lnClosingCharPosition, lnOption, llIsOperator
		
		#Define OPERATORS 	'+-*/=$#%<>'
		lcOperators = Chrtran (OPERATORS, Evl (tcIgnoreTextOperators, ''), '')
		*** JRN 2010-07-06 : Some commands allow wildcards not within string constants
		If (' ' + Upper (Getwordnum (tcCode, 1)) + ' ') $ ' APPEND COPY SORT COPY SCATTER GATHER PRIVATE RELEASE SAVE SET ERASE DELETE COMPILE '
			lcOperators = Chrtran (OPERATORS, '*?-', '')
		Endif
		lcOperators		 = Iif (This.oPrefs.lSpacesAroundOperators, lcOperators, '')
		lcCommaOperators = Iif (This.oPrefs.lSpaceBeforeCommas, ',', '') + lcOperators
		
		lcCode = This.TrimTrailingWhiteSpace (tcCode)
		If Empty (lcCode) ;
				Or Inlist (Getwordnum (tcCode, 1), '*', '#', INLINECOMMENTS, '\') ;
				or Upper(Getwordnum (tcCode, 1)) == 'RUN'
			Return lcCode
		Endif
		
		lcResult = ''
		
		lnCharscount = Len (lcCode)
		lcPrevChar	 = ''
		For lnCharPos = 1 To lnCharscount
		
			lcThisChar	 = Substr (lcCode, lnCharPos, 1)
			lcNextChar	 = Substr (lcCode, lnCharPos + 1, 1)
			lcCharsToAdd = lcThisChar
			llIsOperator = .T.
		
			Do Case
		
					* database!tablename
				Case lcThisChar = '!'					  ;
						And This.isnamechar (lcPrevChar)  ;
						And This.isnamechar (lcNextChar)
					lcCharsToAdd = lcThisChar + lcNextChar
					lnCharPos	 = lnCharPos + 1
		
					* !/
				Case lcThisChar = '!'  ;
						And This.TrimLeadingWhiteSpace (Substr (lcCode, lnCharPos + 1)) = '/'
					For lnCharPos = lnCharPos + 1 To lnCharscount
						lcThisChar	 = Substr (lcCode, lnCharPos, 1)
						lcCharsToAdd = lcCharsToAdd + lcThisChar
						If Not (lcThisChar ISABLANK Or lcThisChar = '/')
							Exit
						Endif
					Endfor
		
					* substitutions for 'NOT' and !
				Case This.oPrefs.nDefinitionForNOT  = 2  ;
						And lcThisChar = '!'	  ;
						And lcNextChar # '='
					lnOption = This.nBeautifyOptions (2)
					lcNot	 = Iif (lnOption = 1, 'NOT', Iif (lnOption = 2, 'not', 'Not'))
					lcCharsToAdd = Iif (lcPrevChar ISABLANK Or lcPrevChar $ '(', '', ' ')  ;
						+ lcNot + Iif (lcNextChar ISABLANK, '', ' ')
		
				Case This.oPrefs.nDefinitionForNOT  = 3							;
						And Not This.isnamechar (lcPrevChar)				;
						And Upper (Substr (lcCode, lnCharPos, 3)) == 'NOT'	;
						And Not This.isnamechar (Substr (lcCode, lnCharPos + 3, 1))
					lcCharsToAdd = Iif (lcPrevChar $ lcCommaOperators, ' ', '') + '!'
					lnCharPos	 = lnCharPos + 2
		
				Case This.isnamechar (lcThisChar)
					* Add a space after operators or commas
					If lcPrevChar $ lcCommaOperators
						* But not if this is negative constant
						If Not (lcPrevChar == "-"															;
								And Isdigit (lcThisChar)													;
								And Right (This.TrimTrailingWhiteSpace (Left (lcCode, lnCharPos - 2)), 1) $ '([,' + lcOperators ;
								)
							lcCharsToAdd = " " + lcCharsToAdd
						Endif
					Endif
		
					* substitutions for  # and != and <>
				Case (Not tlTextMerge) And This.oPrefs.nDefinitionForNOTEQUAL = 2 And Inlist (lcThisChar + lcNextChar, '!=', '<>')
					lcCharsToAdd = Iif (This.oPrefs.lSpacesAroundOperators And Not lcPrevChar ISABLANK, ' ', '') + '#'
					lnCharPos	 = lnCharPos + 1
		
				Case (Not tlTextMerge) And This.oPrefs.nDefinitionForNOTEQUAL = 3 And lcThisChar = '#'
					lcCharsToAdd = Iif (This.oPrefs.lSpacesAroundOperators And Not lcPrevChar ISABLANK, ' ', '') + '!='
		
				Case (Not tlTextMerge) And This.oPrefs.nDefinitionForNOTEQUAL = 3 And lcThisChar + lcNextChar = '<>'
					lcCharsToAdd = Iif (This.oPrefs.lSpacesAroundOperators And Not lcPrevChar ISABLANK, ' ', '') + '!='
					lnCharPos	 = lnCharPos + 1
		
				Case (Not tlTextMerge) And This.oPrefs.nDefinitionForNOTEQUAL = 4 And lcThisChar = '#'
					lcCharsToAdd = Iif (This.oPrefs.lSpacesAroundOperators And Not lcPrevChar ISABLANK, ' ', '') + '<>'
		
				Case (Not tlTextMerge) And This.oPrefs.nDefinitionForNOTEQUAL = 4 And lcThisChar + lcNextChar = '!='
					lcCharsToAdd = Iif (This.oPrefs.lSpacesAroundOperators And Not lcPrevChar ISABLANK, ' ', '') + '<>'
					lnCharPos	 = lnCharPos + 1
		
				Case lcThisChar $ ['"{] Or	;
						(lcThisChar = '[' And Not This.isnamechar (Right (This.TrimTrailingWhiteSpace (lcResult), 1)))
					* Grab entire character string (or date string .. {^2010,10,01}
					lcRestLineString	  = Substr (lcCode, lnCharPos + 1)
					lnClosingCharPosition = At (Iif (lcThisChar = "[", "]", Iif (lcThisChar = "{", "}", lcThisChar)), lcRestLineString)
					lcStringConstant	  = lcThisChar + Left (lcRestLineString, lnClosingCharPosition )
					*** JRN 2010-05-03 : select 'normal' string delimiters
					Do Case
						Case This.oPrefs.nStringDelimiters = 2	 ;
								And lcThisChar = ["]	 ;
								And Not ['] $ lcStringConstant
							lcStringConstant = ['] + Left (lcRestLineString, lnClosingCharPosition - 1) + [']
						Case This.oPrefs.nStringDelimiters = 3	 ;
								And lcThisChar = [']	 ;
								And Not ["] $ lcStringConstant
							lcStringConstant = ["] + Left (lcRestLineString, lnClosingCharPosition - 1) + ["]
						Case This.oPrefs.nStringDelimiters = 4	 ;
								And lcThisChar $ ['"]	 ;
								And Not ('[' $ lcStringConstant Or ']' $ lcStringConstant)
							lcStringConstant = '[' + Left (lcRestLineString, lnClosingCharPosition - 1) + ']'
					Endcase
		
					lcCharsToAdd = lcStringConstant
					lcThisChar	 = Right (lcStringConstant, 1)
					lnCharPos	 = lnCharPos + lnClosingCharPosition
					* Add a space after operators or commas
					If lcPrevChar $ lcCommaOperators
						lcCharsToAdd = " " + lcCharsToAdd
					Endif
		
				Case lcPrevChar == "&" And lcThisChar == "&"
					* double && -- trailing comment
					lcResult = lcResult + Substr (lcCode, lnCharPos)
					Exit
		
				Case lcPrevChar == "(" Or lcThisChar == ")"
					* no spaces after ( or before )
		
					* Case lcThisChar $ lcOperators And lcPrevChar $ lcOperators
		
				Case tlTextMerge And lcPrevChar + lcThisChar = '<<'
					* no added space after << within text merging
					lcCharsToAdd = lcThisChar + lcNextChar
					lnCharPos	 = lnCharPos + 1
		
				Case tlTextMerge And lcThisChar + lcNextChar = '>>'
					* no added space before >> within text merging
		
				Case lcThisChar + lcNextChar = '->'
					* no added space before >> within text merging
					lcCharsToAdd = lcThisChar + lcNextChar + Substr (lcCode, lnCharPos + 2, 1)
					lnCharPos	 = lnCharPos + 2
		
				Case Inlist (lcPrevChar + lcThisChar, "<=", ">=", "<>", "==", "!=", "**", ".*", "<<", ">>", "{/", "//", "/:", "/}", "--", "/*", "*/", "=<", "=>")
					* Special cases for  <=   >=   <>   ==   !=  **   .*
		
				Case lcThisChar == "+" And							;
						(											;
						Upper (Right (lcResult, 3)) == "ALT" Or	;
						Upper (Right (lcResult, 4)) == "CTRL" Or	;
						Upper (Right (lcResult, 5)) == "SHIFT"	;
						)
					* no space for hotkey definitions (CTRL+X, etc)
					lcCharsToAdd = lcThisChar + lcNextChar
					lnCharPos	 = lnCharPos + 1
		
				Case lcThisChar $ lcOperators And Not (lcPrevChar ISABLANK)
					* space before operators (finally!)
					If lnCharPos > 1
		
						***********************************************
						If Not Empty (This.cpluginisoperator)
						* 2011.11.22 MarioPeschke
						*            allowed to add spaces, only for specific structures
							Try
								llIsOperator = Execscript (This.cpluginisoperator, lcCode,lnCharPos)
							Catch To loException
								This.ShowErrorMsg (loException, 'IsOperator Failure')
							Endtry
						Endif
						If llIsOperator
							lcCharsToAdd = " " + lcThisChar
						Endif
					Endif
		
				Case This.oPrefs.nBeforeLeftParens = 3	 ;
						And lcThisChar = '('			 ;
						And (Not (lcPrevChar ISABLANK))	 ;
						And (Not (Isdigit (lcNextChar) Or lcNextChar = ')'))
					* (conditionally) add space before left parenthesis
					lcCharsToAdd = " " + lcThisChar
		
				Case (lcThisChar == "," And This.oPrefs.lSpaceBeforeCommas) Or (lcThisChar = '(' And This.oPrefs.nBeforeLeftParens = 2)
					* remove spaces or tabs before comma and left parentheses
					If Not Empty (lcResult)
						lcResult = This.TrimTrailingWhiteSpace (lcResult)
					Endif
					* but leave spaces between multiples commas   (a, b, , ,)
					If Right (lcResult, 1) = ','
						lcCharsToAdd = ' ' + lcThisChar
					Endif
		
					* Add a space after operators or commas
				Case lcPrevChar $ lcCommaOperators And Not lcThisChar ISABLANK
					lcCharsToAdd = " " + lcCharsToAdd
		
			Endcase
		
			lcResult   = lcResult + lcCharsToAdd
			If llIsOperator
				lcPrevChar = Right (lcCharsToAdd, 1)
			Else
				lcPrevChar = 'X'
		 	EndIf 
		
		Endfor
		
		Return lcResult
		
		
	ENDPROC

	PROCEDURE beautifyword
		Lparameters tcWord
		
		Local lcWord
		Do Case
			Case This.nBeautifyOptions(2) = 1
				lcWord = Upper(tcWord)
			Case This.nBeautifyOptions(2) = 2
				lcWord = Lower(tcWord)
			Otherwise
				lcWord = Proper(tcWord)
		Endcase
		
		Return lcWord
	ENDPROC

	PROCEDURE calccolumn
		Lparameters lcLine, lcText
		Local lcLeft, lnPos 
		
		lnPos = 1 + At (' ' + lcText + ' ', Strtran (Upper (lcLine), Tab, ' ', 1, 999))
		If lnPos <= 1
			Return lcLine
		Endif
		
		lcLeft = Left (lcLine, lnPos - 1)
		Return This.CountCharacterWidth (This.TrimTrailingWhiteSpace (lcLeft))
		
		
		
		
	ENDPROC

	PROCEDURE calccolumnoffset		&& Given a starting column, offsets it; primarily for handling tabs
		Lparameters lnCol, lnOffset
		
		If lnOffset <= 4
			Return lnCol + 1 + lnOffset
		Else
			Return (lnCol - lnCol % This.nTabWidth) + This.nTabWidth + 1 + IIf (lnOffset = 5, 0, This.nTabWidth)
		Endif
		
	ENDPROC

	PROCEDURE converttabsforindent
		Lparameters lcNewIndent
		
		If This.oPrefs.lUseTabs
			Return Strtran (lcNewIndent, Space (This.nTabWidth), Tab)
		Else
			Return lcNewIndent
		Endif
		
	ENDPROC

	PROCEDURE createidlist
		Lparameters lcProcName, lnStartLine, lnEndLine
		
		Local loRegExp As 'VBScript.RegExp'
		Local laLocals[1], laParens[1], lcName, lcNewCode, lcNotNameChars, lcRestLineString, lcSourceLine
		Local lcThisChar, lcUpperWord, lcWord, lcWord1, lcWord2, lcWordNew, llAssign, llLongEnough
		Local lnCharPos, lnClosingCharPosition, lnI, lnJ, lnLineCount, lnLoop, lnLoopStartValue
		Local lnParenCount, lnParenLevel, lnPos, lnType
		
		With This
			.FixWithStatements() && this is for setup only
			.nNewLocalsCount	  = 0
			.cCurrentLocals		  = This.FindCurrentLocals (lnStartLine, lnEndLine)
			.lNoDotsInAssignments = .F.
			.CreateNewLocals (lnStartLine, lnEndLine, .T.)
		Endwith
		
		lcNotNameChars = Chrtran (NOTNAMECHARS, '&\(^),', '') + Tab + CR + LF
		
		loRegExp = This.oUtils.GetRegExp()
		
		****************************************************************
		For lnLoop = lnStartLine To lnEndLine
			lnLoopStartValue = lnLoop
			lcSourceLine	 = ' ' + This.GetSourceCodeLine (@lnLoop, .T.)
		
			If Empty (lcSourceLine)
				Loop
			Endif
		
			With loRegExp
				* replace all white space and sem-colons with simple white space
				.Pattern	 = '(\s+|;)'
				lcSourceLine = .Replace (lcSourceLine, ' ')
			Endwith
		
			lcWord1		 = Upper (Getwordnum (lcSourceLine, 1))
			lcWord2		 = Getwordnum (lcSourceLine, 2)
			llLongEnough = Len (lcWord1) >= 4
		
			*** JRN 2010-08-16 : pseudo line allowed to identify tables in use
		
			If Inlist (lcWord1, '*', '#', INLINECOMMENTS)
				Loop
			Endif
		
			If llLongEnough And 'EXTERNAL' = lcWord1
				Loop
			Endif
		
			Insert Into crsr_IDs_Lines				;
				(ProcID, SourceLine, Lineno)		;
				Values								;
				(crsr_IDs_Procs.Id, lcSourceLine, lnLoopStartValue)
		
			This.lFieldReference = llLongEnough And (											;
				'SELECT' = lcWord1															;
				Or 'UPDATE' = lcWord1															;
				Or 'REPLACE' = lcWord1														;
				Or 'INSERT' = lcWord1															;
				Or ('CREATE' = lcWord1 And Inlist (Upper (lcWord2), 'TABLE', 'CURSOR'))		;
				)
		
			If lcWord1 == 'DECLARE'
				If 'IN' == Upper (Getwordnum (lcSourceLine, 3))
					This.InsertID (Getwordnum (lcSourceLine, 2), TYPE_Declared)
				Else
					This.InsertID (Getwordnum (lcSourceLine, 3), TYPE_Declared)
				Endif
				Loop
			Endif
		
			lcNewCode	 = This.ParseLineForIDList (lcSourceLine, lcNotNameChars)
			lnParenLevel = 0
		
			With loRegExp
				.Pattern  = '(Alt|Shift|Ctrl)\s+\+\s'
				lcNewCode = .Replace (lcNewCode, '$1+')
			Endwith
		
			If Upper (lcNewCode) = ' *{PEME:TABLES}'
				lcSourceLine = 'From ' + Substr (lcNewCode, 16)
			Endif
		
			If llLongEnough
				If 'LOCAL' = lcWord1 Or 'PRIVATE' = lcWord1
					This.InsertLocalIDs (lcNewCode, TYPE_Locals, 2)
					Loop
				Endif
		
				If 'LPARAMETERS' = lcWord1 Or 'PARAMETERS' = lcWord1
					This.InsertLocalIDs (lcNewCode, TYPE_Parameters, 2)
					Loop
				Endif
		
				If 'PROCEDURE' = lcWord1 Or 'FUNCTION' = lcWord1
					This.InsertID (lcProcName, Iif('.' $ lcProcName, TYPE_Methods, TYPE_Procedures))
					This.InsertLocalIDs (lcNewCode, TYPE_Parameters, 3)
					Loop
				Endif
		
				If 'HIDDEN' = lcWord1 Or 'PROTECTED' = lcWord1
					This.InsertID (lcProcName, Iif('.' $ lcProcName, TYPE_Methods, TYPE_Procedures))
					This.InsertLocalIDs (lcNewCode, TYPE_Parameters, 4)
					Loop
				Endif
		
			Endif
		
			For lnI = 1 To Getwordcount (lcNewCode)
				lcWord		= Getwordnum (lcNewCode, lnI)
				lcUpperWord	= Upper (lcWord)
		
				Do Case
		
					Case Left (lcUpperWord, 1) $ '^+'
		
					Case lcUpperWord = '('
						lnParenLevel = lnParenLevel + 1
		
					Case lcUpperWord = ')'
						lnParenLevel = lnParenLevel - 1
		
					Case lcUpperWord == 'DO'
						Do Case
							Case Upper (lcWord2) == 'CASE'
							Case Upper (lcWord2) == 'WHILE'
							Case Upper (lcWord2) == 'FORM'
								lnType = TYPE_Forms
								lcWord = Getwordnum (lcNewCode, lnI + 2)
								This.InsertID (lcWord, lnType)
							Otherwise
								lnType = TYPE_Procedures
								lcWord = Getwordnum (lcNewCode, lnI + 1)
								This.InsertID (lcWord, lnType)
						Endcase
		
						* Tables
					Case lcUpperWord == 'USE'
						lnType = TYPE_Tables
						lcWord = Getwordnum (lcNewCode, lnI + 1)
						This.InsertID (lcWord, lnType)
		
					Case lcUpperWord == 'JOIN'
						lnType = TYPE_Tables
						lcWord = Getwordnum (lcNewCode, lnI + 1)
						This.InsertID (lcWord, lnType)
						Do Case
							Case Upper (Getwordnum (lcNewCode, lnI + 2)) == 'AS'
								lcWord = Getwordnum (lcNewCode, lnI + 3)
								This.InsertID (lcWord, lnType)
							Case Not Upper (Getwordnum (lcNewCode, lnI + 2)) == 'ON'
								lcWord = Getwordnum (lcNewCode, lnI + 2)
								This.InsertID (lcWord, lnType)
						Endcase
		
					Case lcUpperWord == 'FROM'
						lnType = TYPE_Tables
						For lnJ = lnI + 1 To Getwordcount (lcNewCode)
							lcWord = Getwordnum (lcNewCode, lnJ)
							This.InsertID (lcWord, lnType)
							lcWordNew = Getwordnum (lcNewCode, lnJ + 1)
							Do Case
								Case Empty (lcWord)
									Exit
								Case Upper (lcWordNew) == 'AS'
									lnJ = lnJ + 1
								Case lcWordNew = ','
									lnJ = lnJ + 1
								Case This.Iskeyword (lcWordNew)
									Exit
							Endcase
						Endfor
		
					Case lcUpperWord == 'IN' And lcWord1 # 'FOR'
						lnType = TYPE_Tables
						lcWord = Getwordnum (lcNewCode, lnI + 1)
						If Not Inlist (Upper (lcWord) + ' ', 'SCREEN ', 'WIN32API ', 'KERNEL32 ')
							This.InsertID (lcWord, lnType)
						Endif
		
					Case lcUpperWord == 'SELECT'
						lnType = TYPE_Tables
						lcWord = Getwordnum (lcNewCode, lnI + 1)
						If Empty (Getwordnum (lcNewCode, lnI + 2))
							This.InsertID (lcWord, lnType)
						Endif
		
					Case lcUpperWord == 'CREATE' And Inlist (' ' + Upper (Getwordnum (lcNewCode, lnI + 1)), ' TABLE', ' CURSOR')
						lnType = TYPE_Tables
						lcWord = Getwordnum (lcNewCode, lnI + 2)
						This.InsertID (lcWord, lnType)
		
					Case lcUpperWord == 'INSERT' And Upper (Getwordnum (lcNewCode, lnI + 1)) =  'INTO'
						lnI	   = lnI + 2
						lcWord = Getwordnum (lcNewCode, lnI)
		
						Do Case
							Case lcWord = '('
								Do While .T.
									lnI		= lnI + 1
									lcWord2	= Getwordnum (lcNewCode, lnI)
									If Empty (lcWord2) Or lcWord2 = ')'
										Exit
									Else
										This.InsertIDOthers (lcWord2, Getwordnum (lcNewCode, lnI + 1))
									Endif
								Enddo
								lcWord = '?Table'
								lnType = TYPE_Tables
								This.InsertID (lcWord, lnType)
		
							Case lcWord = '^'
								lcWord = '?Table'
								lnType = TYPE_Tables
								This.InsertID (lcWord, lnType)
		
							Otherwise
								lnType = TYPE_Tables
								This.InsertID (lcWord, lnType)
						Endcase
		
						lnI		= lnI + 1
						lcWord2	= Getwordnum (lcNewCode, lnI)
						If lcWord2 = '('
							Do While .T.
								lnI		= lnI + 1
								lcWord2	= Getwordnum (lcNewCode, lnI)
								If Empty (lcWord2) Or lcWord2 = ')'
									Exit
								Else
									This.InsertID (lcWord + '.' + lcWord2, TYPE_Objects)
								Endif
							Enddo
						Endif
		
					Case lcUpperWord == 'INTO' And Inlist (' ' + Upper (Getwordnum (lcNewCode, lnI + 1)), ' TABLE', ' CURSOR')
						lnType = TYPE_Tables
						lcWord = Getwordnum (lcNewCode, lnI + 2)
						This.InsertID (lcWord, lnType)
		
					Case Inlist (lcUpperWord, 'UPDATE', 'ALIAS')
						lnType = TYPE_Tables
						lcWord = Getwordnum (lcNewCode, lnI + 1)
						This.InsertID (lcWord, lnType)
		
					Case 1 = Len (lcWord) And lcUpperWord $ ASDATATYPE_CHARS
						* do nothing for single character names that can be used in Cast( AS ...) or Create Cursor or Create Table
		
					Otherwise
						This.InsertIDOthers (lcWord, Getwordnum (lcNewCode, lnI + 1))
		
				Endcase
			Endfor
		
		Endfor
		
		Return
		
	ENDPROC

	PROCEDURE createidlistcursors
		Create Cursor crsr_IDs_Procs (			;
			  Id     		I AutoIncr,			;
			  ProcName   	C(250),				;
			  StartLine	    N(6)				;
			  )
		
		Create Cursor crsr_IDs_Lines (			;
			  Id     		I AutoIncr,			;
			  ProcID        I,					;
			  SourceLine	M,					;
			  Lineno		N(4),				;
			  AnyFound		L					;
			  )
		
		Create Cursor crsr_IDs_Refs (		;
			  ProcID        I,				;
			  LineID		I,				;
			  Name		 	C(100),			;
			  Type      	N(2)			;
			  )
		
		Create Cursor crsr_IDs_Constants  (			;
			  Constant      C(100)				;
			  )
	ENDPROC

	PROCEDURE createidlistsummary
		Lparameters lcProcName
		Local laLocals[1], lcName, lnI, lnLineCount
		
		Select  Distinct									;
				Upper (Name)		 As	 UpperName,			;
				TYPE_Tables			 As	 nNewType,			;
				Len (Trim (Name))	 As	 nLength			;
			From crsr_IDs									;
			Where nType = TYPE_Tables						;
			Into Cursor crsr_Tables Readwrite
		
		Select  Upper (Name)				   As  UpperName,											;
				Min (Name)					   As  Name,												;
				Min (Nvl (nNewType, nType))	   As  nType												;
			From crsr_IDs																				;
				Left Join crsr_Tables																	;
					On Left (crsr_Tables.UpperName, nLength) = Upper (Left (crsr_IDs.Name, nLength))	;
					And Substr (crsr_IDs.Name, nLength + 1, 1) $ ' .'									;
			Where Upper (Name) # Upper (Evl (lcProcName, '??'))											;
			Group By 1																					;
			Order By 3, 1																				;
			Into Cursor crsr_Summary
		
		
	ENDPROC

	PROCEDURE createlocalsforcodeblock
		Lparameters lcCodeSource, lnWindowType, lnCurrentLine, llLocalsAllProcs
		Local lcCode, lcName, lcNewCode, lcType, lnEnd, lnI, lnJ, lnStart 
		
		This.SetBeautifyOptions()
		Alines (This.aCodeLines, lcCodeSource + ' ')
		
		Do Case
			Case lnWindowType = 10 && Method Code
				lcNewCode = This.DoLocals (1, Alen (This.aCodeLines))
			Case lnWindowType = 1 && PRG
				This.ParsePRGCodeBlocks ()
				lcNewCode = ''
				For lnI = 1 To Alen (This.aPRGCodeBlocks, 1)
					lcName	= This.aPRGCodeBlocks (lnI, 1)
					lcType	= This.aPRGCodeBlocks (lnI, 2)
					lnStart	= This.aPRGCodeBlocks (lnI, 3)
					lnEnd	= This.aPRGCodeBlocks (lnI, 4)
					If lcType $ 'PF' And (		;
							  llLocalsAllProcs Or Between (lnCurrentLine + 1, lnStart, lnEnd))
						lcCode	  = This.DoLocals (lnStart, lnEnd)
						lcNewCode = IIf (Empty (lcNewCode), '', lcNewCode + LINEEND) + lcCode
					Else
						For lnJ = lnStart To lnEnd
							lcNewCode = IIf (Empty (lcNewCode), '', lcNewCode + LINEEND) + This.aCodeLines (lnJ)
						Endfor
					Endif
				Endfor
			Otherwise
				Return
		Endcase
		
		Return lcNewCode
		
	ENDPROC

	PROCEDURE createlocalstatements
		Local laLocals[1]
		Local lcArrayDims, lcASPhrase, lcCode, lcLine, lcLocalName, lcLocalPhrase, lcLocalsPlugIn, lcName
		Local lcResult, lcVar, llAlreadyLocal, llArray, llCommasBeforeLocals, llContinuation, llHasASPhrase
		Local llStartsWithL, llUseAsPhrase, llUseTabs, lnMaxWidth, lnRow, lnSelectionType, lnType
		Local llAssigned, llRemoveOrphanLocals, llSortCreatedLocals  
		
		If This.nNewLocalsCount = 0
			Return ''
		Endif
		
		lcLocalsPlugIn = This.oUtils.GetPlugInPath ("CreateLocalsStatements")
		If Not Empty (lcLocalsPlugIn)
			Acopy (This.aNewLocals, laLocals)
			lcCode = Execscript (Filetostr (lcLocalsPlugIn), @laLocals)
			Return lcCode
		Endif
		
		****************************************************************
		
		This.SetBeautifyOptions()
		lcLocalName = This.BeautifyWord('Local ')
		llUseTabs = This.nBeautifyOptions(4) = 1
		
		With This.oPrefs
			llContinuation		 = Not .lLocalsMultPerLine
			lnSelectionType		 = .nLocalsSelectionType
			lnMaxWidth			 = .nLocalsLineWidth
			llUseAsPhrase		 = .lLocalsUseAS
			llCommasBeforeLocals = .lCommasBeforeLocals
			llRemoveOrphanLocals = .lRemoveOrphanLocals
			llSortCreatedLocals  = .lSortCreatedLocals 
		Endwith
		
		****************************************************************
		With This
		
			If llSortCreatedLocals  
				Asort (.aNewLocals, 1, -1, 0, 0)
			EndIf 
		
			lcResult = ''
			For lnType = 1 To 4
				lcLine = ''
				For lnRow = 1 To Alen (.aNewLocals, 1)
		
					lcName		   = .aNewLocals (lnRow, 1)
					lcASPhrase	   = .aNewLocals (lnRow, 2)
					llArray		   = .aNewLocals (lnRow, 3)
					llHasASPhrase  = .aNewLocals (lnRow, 4)
					llStartsWithL  = .aNewLocals (lnRow, 5)
					llAlreadyLocal = .aNewLocals (lnRow, 6)
					lcArrayDims	   = .aNewLocals (lnRow, 7)
					llAssigned     = .aNewLocals (lnRow, 8)
		
					lcName = lcName + IIf (llArray, '[' + lcArrayDims + ']', '')
		
					Do Case
		
							****************************************************************
						Case llRemoveOrphanLocals and llAlreadyLocal and (not llAssigned) and (not llArray)
							Loop
							
						Case llUseAsPhrase And llStartsWithL
							If lnType = 1
								lcVar		  = This.AddASPhase (lcName, lcASPhrase)
								lcLocalPhrase = lcLocalName
							Else
								Loop
							Endif
		
						Case llUseAsPhrase And lnType = 1 And lnSelectionType = 4
							lcVar		  = This.AddASPhase (lcName, lcASPhrase)
							lcLocalPhrase = lcLocalName
		
						Case llUseAsPhrase And lnType = 2 And lnSelectionType = 3
							lcVar		  = This.AddASPhase (lcName, lcASPhrase)
							lcLocalPhrase = lcLocalName
		
						Case llUseAsPhrase And lnType = 3 And lnSelectionType = 2
							lcVar		  = This.AddASPhase (lcName, lcASPhrase)
							lcLocalPhrase = '*:Global '
		
						Case llUseAsPhrase
							Loop
		
							****************************************************************
						Case lnSelectionType = 1 And Not llStartsWithL
							Loop
		
						Case llHasASPhrase And lnType = 1
							lcVar		  = lcName + This.BeautifyWord(' as ') + lcASPhrase
							lcLocalPhrase = lcLocalName
						Case llHasASPhrase
							Loop
		
						Case llStartsWithL And lnType = 2
							lcVar		  = lcName
							lcLocalPhrase = lcLocalName
						Case llStartsWithL
							Loop
		
						Case lnSelectionType = 4 And lnType = 2
							lcVar		  = lcName
							lcLocalPhrase = lcLocalName
		
						Case lnSelectionType = 2 And lnType = 3 And llAlreadyLocal
							lcVar		  = lcName
							lcLocalPhrase = lcLocalName
		
						Case lnSelectionType = 2 And lnType = 4 And Not llAlreadyLocal
							lcVar		  = lcName
							lcLocalPhrase = '*:Global '
						Case lnSelectionType = 3 And lnType = 4
							lcVar		  = lcName
							lcLocalPhrase = lcLocalName
		
						Otherwise
							Loop
					Endcase
		
					Do Case
						Case Empty (lcLine)
							lcLine = lcLocalPhrase  + lcVar
						Case llContinuation Or llUseAsPhrase
							If llCommasBeforeLocals
								lcLine = lcLine + ';' + LINEEND + IIf (llUseTabs, Tab, '') + ', ' + lcVar
							Else
								lcLine = lcLine + ', ;' + LINEEND + IIf (llUseTabs, Tab, '') + lcVar
							Endif
						Case lnType # 1 And (Len (lcLine) + 2 + Len (lcVar)) <= lnMaxWidth
							lcLine = lcLine + ', ' + lcVar
						Otherwise
							lcResult = lcResult + lcLine + LINEEND
							lcLine	 = lcLocalPhrase  + lcVar
					Endcase
				Endfor
		
				If Not Empty (lcLine)
					lcResult = lcResult + lcLine + LINEEND
				Endif
			Endfor
		
		Endwith
		
		Return Left (lcResult, Len (lcResult) - 2)
		
	ENDPROC

	PROCEDURE createnewlocals
		Lparameters lnStartLoop, lnEndLoop, llFixWITHs
		* This.aNewLocals:
		*    Col 1 = Local Name
		*    Col 2 = AS blabla
		*    Col 3 = Array?
		*    Col 4 = Col 2 non-empty
		*    Col 5 = Begins with lowercase 'l'
		*    Col 6 = Already found in LOCALs
		*    Col 7 = Array parameters
		*    Col 8 = Actual assignment?
		*    Col 9 = <Unused>
		*    Col 10 = <Unused>
		
		Local laLocals[1], laWithEndWith[1]
		Local lcArrayFunc, lcArrayFunctions, lcArrayLine, lcArrayParse, lcASPhrase, lcChar
		Local lcCurrentWithEndWith, lcDims, lcExpression, lcName, lcObjClassLib, lcObjType, lcParams, lcParse
		Local lcSourceLine, lcTmp, lcVar, lcWord, lcWord1, lcWord2, llCreateObject, llFirstTimeThru, llNameOK
		Local lnI, lnLoop, lnPos, lnWithEndWithLevel, lnWord
		
		llFirstTimeThru = .T.
		This.FixWithStatements()
		
		For lnLoop = lnStartLoop To lnEndLoop
			lcSourceLine = This.GetSourceCodeLine (@lnLoop, , .T.)
			lcWord1 = Lower (Getwordnum (lcSourceLine, 1))
			lcWord2 = Lower (Getwordnum (lcSourceLine, 2))
		
			If llFixWITHs
				lcSourceLine = This.FixWithStatements(lcSourceLine)
			Endif
		
			lcParse = ''
			If Empty (lcSourceLine) Or lcWord1 = '*'
				Loop
			Endif
		
			Do Case
		
				Case 'procedure ' = lcWord1 Or 'function ' = lcWord1
					If Not llFirstTimeThru
						Exit
					Endif
		
				Case ('protected ' = lcWord1 Or 'hidden ' = lcWord1)		;
						And ('procedure ' = lcWord2 Or 'function ' = lcWord2)
					If Not llFirstTimeThru
						Exit
					Endif
		
				Case ' to array ' $ Lower (lcSourceLine) And (		;
						'copy ' = lcWord1							;
						Or 'scatter ' = lcWord1					;
						Or 'sum ' = lcWord1						;
						Or 'calculate ' = lcWord1					;
						Or 'average ' = lcWord1					;
						)
					lcParse = Substr (lcSourceLine, Rat ([ to ], Lower (lcSourceLine)) + 10)
					For lnWord = 1 To 1000
						lcWord = Alltrim (Getwordnum (lcParse, lnWord, ','))
						If Empty (lcWord)
							Exit
						Else
							This.AddNewLocal (Getwordnum (lcWord, 1), , .T.)
						Endif
					Endfor
		
				Case ' to ' $ Lower (lcSourceLine) And (		;
						'store ' = lcWord1					;
						Or 'calculate ' = lcWord1				;
						Or 'average ' = lcWord1				;
						Or 'sum ' = lcWord1					;
						Or 'count ' = lcWord1					;
						Or 'wait ' = lcWord1					;
						Or 'catch ' = lcWord1					;
						)
					lcParse = lcSourceLine			
					lcParse = This.RemoveParens(lcParse)
					If ' to ' $ Lower (lcParse)
						lcParse = Substr (lcParse, Rat ([ to ], Lower (lcParse)) + 4)
						lcParse = Strtran(lcParse, ';', ' ')
						For lnWord = 1 To 1000
							lcWord = Alltrim (Getwordnum (lcParse, lnWord, ','))
							If Empty (lcWord) 
								Exit
							Else
								This.AddNewLocal (Getwordnum (lcWord, 1))
								If 1 # GetWordCount(lcWord)
									Exit
								EndIf 
							Endif
						EndFor
					EndIf 
		
				Case 'dimension ' = lcWord1
					lcSourceLine = Alltrim (lcSourceLine)
					lcParse = Substr (lcSourceLine, At (' ', lcSourceLine) + 1)
					If Not Empty (lcParse)
						Dimension laLocals(1)
						This.ParseCodeLine (lcParse, @laLocals, .T.)
		
						For lnI = 1 To Alen (laLocals, 1)
							lcName = laLocals (lnI, 1)
							lcDims = laLocals (lnI, 2)
							lcASPhrase = laLocals (lnI, 3)
							This.AddNewLocal (lcName, , .T.)
						Endfor
					Endif
		
				Case 'catch ' = lcWord1 And 'to ' = lcWord2
					This.AddNewLocal (Getwordnum (lcSourceLine, 3))
				Case 'select ' = lcWord1 And ' into array ' $ Lower (lcSourceLine)
					lcParse = GetWordNum (Substr (lcSourceLine, Rat (' into array ', Lower (lcSourceLine)) + 12), 1)
					This.AddNewLocal (lcParse + '(1)')
				Case 'scatter ' = lcWord1 And ' name ' $ Lower (lcSourceLine)
					lcParse = Strextract (lcSourceLine, ' name ', ' ', 1, 1 + 2)
					This.AddNewLocal (Getwordnum (lcParse, 1))
				Case Lower (Left (lcSourceLine, 9)) = 'for each '
					lcParse = Strextract (lcSourceLine, 'for each ', ' ', 1, 3)
					If ' as ' $ Lower (lcSourceLine)
						lcASPhrase = Strextract (lcSourceLine, ' as ', ' ', 1, 3)
						This.AddNewLocal (Getwordnum (lcParse, 1), Getwordnum (lcASPhrase, 1))
					Else
						This.AddNewLocal (Getwordnum (lcParse, 1))
					Endif
				Case 'for ' = lcWord1
					lcParse = Strextract (lcSourceLine, 'for ', '=', 1, 3)
					This.AddNewLocal (lcParse)
				Case Left (Lower (lcSourceLine), 8) = 'text to '
					lcParse = Getwordnum (lcSourceLine, 3)
					This.AddNewLocal (lcParse)
				Case '=' $ lcSourceLine
					lnPos = At ('=', lcSourceLine)
					lcVar = Alltrim (Left (lcSourceLine, lnPos - 1))
					lcExpression = Alltrim (Substr (lcSourceLine, lnPos + 1))
					llNameOK = .T.
					For lnI = 1 To Len (lcVar)
						lcChar = Substr (lcVar, lnI, 1)
						llNameOK = llNameOK And (This.IsNameChar (lcChar) Or lcChar $ '.()[]')
					Endfor
					If llNameOK
						lcASPhrase = ''
						If Inlist (Lower (Left (lcExpression, 9)), 'newobject', 'createobj')
							llCreateObject = (Lower (Left (lcExpression, 9)) == 'createobj')
							lcExpression = Alltrim (Strextract (lcExpression, [(]))
							If Right (lcExpression, 1) = [)]
								lcExpression = Left (lcExpression, Len (lcExpression) - 1)
							Endif
							lcObjType = Alltrim (Getwordnum (lcExpression, 1, [,]))
							lcObjClassLib = Alltrim (Getwordnum (lcExpression, 2, [,]))
							If Empty (lcObjClassLib) Or llCreateObject
								If Left (lcObjType, 1) $ (['"] + '[')
									lcASPhrase = lcObjType
								Endif
							Else
								If Left (lcObjType, 1) $ (['"] + '[') And Left (lcObjClassLib, 1) $ (['"] + '[')
									lcASPhrase = lcObjType + [ OF ] + lcObjClassLib
								Endif
							Endif
						Endif
						This.AddNewLocal (lcVar, lcASPhrase)
					Endif
			Endcase
		
			*-- THM 08/31/2006 - Support for inline array functions.
			*Support for array functions - lines may contain more than one of these....
			*-- RCE 01/23/2009 - respect Current Locals
			lcArrayFunctions = 'aclass,acopy,adatabases,adbobjects,adir,adlls,adockstate,aerror,aevents,afields,' ;
				+ 'afont,agetclass,agetfileversion,ainstance,alanguage,alines,amembers,amouseobj,anetresources,aprinters,' ;
				+ 'aprocinfo,aselobj,asessions,asqlhandles,astackinfo,ataginfo,aused,avcxclasses'
			lcArrayParse = ''
			lcArrayLine = Chrtran (lcSourceLine, ' ', '')
			For lnI = 1 To Getwordcount (lcArrayFunctions, ',')
				lcArrayFunc = Getwordnum (lcArrayFunctions, lnI, ',')
				*** JRN 2010-04-21 : check character before reference to make sure it is not part of a name ... laMouseObj, e.g.,
				If lcArrayFunc + '(' $ Lower (lcArrayLine)
					lnPos = At (lcArrayFunc + '(', Lower (lcArrayLine))
					If Not This.IsNameChar (Substr (lcArrayLine, lnPos - 1, 1))
						lcParams = Strextract (Substr (lcArrayLine, lnPos), '(', ')')
						This.AddNewLocal (Getwordnum (lcParams, 1, ','), , .T.)
						If lcArrayFunc = 'acopy'
							This.AddNewLocal (Getwordnum (lcParams, 2, ','), , .T.)
						Endif
					Endif
				Endif
			Endfor
		
			*-- THM 08/31/06 - Support for 'DO FORM'
			*-- RCE 01/23/09 - Support for WITH clause; respect Current Locals
			If Left (Lower (lcSourceLine), 8) = 'do form '
				If ' to ' $ Lower (lcSourceLine)
					lcTmp = Getwordnum (Substr (lcSourceLine, Rat ([ to ], Lower (lcSourceLine)) + 4), 1)
					This.AddNewLocal (lcTmp)
				Endif
		
				If ' name ' $ Lower (lcSourceLine)
					lcTmp = Getwordnum (Substr (lcSourceLine, Rat ([ name ], Lower (lcSourceLine)) + 6), 1)
					This.AddNewLocal (lcTmp, 'Form')
				Endif
		
			Endif
			llFirstTimeThru = .F.
		Endfor
		
	ENDPROC

	PROCEDURE doformidlist
		Lparameters lnHandle, lcSourceFileName, lcClassName
		
		Local loFormIDList As 'FrmIDList' Of 'Source\EditProperty.VCX'
		Select  *						;
			From crsr_IDs_Lines			;
			Where AnyFound				;
			Into Cursor crsr_IDS_Lines2
		
		loFormIDList 	 = Newobject ('FrmIDList', 'Source\EditProperty.VCX', ''		;
			  , This.oUtils.ConvertCursortoXML ('crsr_IDs_Procs')						;
			  , This.oUtils.ConvertCursortoXML ('crsr_IDs_Lines2')						;
			  , This.oUtils.ConvertCursortoXML ('crsr_IDs_Refs')						;
			  , This.oUtils.ConvertCursortoXML ('crsr_IDs_Constants')					;
			  , This.oUtils.cApplicationPath											;
			  , This.oUtils																;
			  , lnHandle, lcSourceFileName, lcClassName									;
			  )
		
		loFormIDList.Show()
		
		* following allows this to be kept around after this method ends
		* and also to be cleaned up when _oPEMEditor closes
		This.oUtils.AddProperty ('o' + Sys(2015), loFormIDList)
		
	ENDPROC

	PROCEDURE doidlisttext
		Lparameters lcSourceLine, lnLoop, lnLinesCount
		
		Local lcFirstWord, lcLine, lcType, lnI
		Do Case
			Case '{PEME:IGNORE}' $ Upper (lcSourceLine)
				lcType = 'Ignore'
			Case '{PEME:CODE}' $ Upper (lcSourceLine)
				lcType = 'Code'
			Case '{PEME:SELECT}' $ Upper (lcSourceLine)
				lcType = 'Select'
			Case This.oPrefs.lBeautifyTEXTasSelect
				For lnI = lnLoop + 1 To lnLinesCount
					lcLine		= This.aCodeLines[lnI]
					lcFirstWord	= Upper (Getwordnum (lcLine, 1))
					Do Case
						Case Empty (lcFirstWord)
		
						Case 'SELECT ' = lcFirstWord
							lcType = 'Select'
							Exit
						Otherwise
							lcType = 'Ignore'
							Exit
					Endcase
				Endfor lnI = lnLoop + 1 To lnLinesCount
			Otherwise
				lcType = 'Ignore'
		Endcase
		
		If lcType = 'Ignore'
			For lnI = lnLoop + 1 To lnLinesCount
				lcLine		= This.aCodeLines[lnI]
				lcFirstWord	= Upper (Getwordnum (lcLine, 1))
				If lcFirstWord == 'ENDTEXT'
					Return lnI
				Endif
			Endfor lnI = lnLoop + 1 To lnLinesCount
		Endif lcType = 'Ignore'
		
		Return lnLoop
	ENDPROC

	PROCEDURE dolocals
		Lparameters lnStartLine, lnEndLine
		Local lcLocalStatements, lcNewCode, lcSourceLine, lcWord1, llAddTheseLines, llInsertLocalsLater
		Local llInsertNewLocals, lnI, lnLoop, lnLoopValueBefore
		
		This.nNewLocalsCount = 0
		Dimension This.aNewlocals(1,10)
		* This.aNewLocals:
		*    Col 1 = Local Name
		*    Col 2 = AS blabla
		*    Col 3 = Array?
		*    Col 4 = Col 2 non-empty
		*    Col 5 = Begins with lowercase 'l'
		*    Col 6 = Already found in LOCALs
		*    Col 7 = Array parameters
		*    Col 8 = Actual assignments
		*    Col 9 = <Unused>
		*    Col 10 = <Unused>
		
		This.cCurrentLocals = This.FindCurrentLocals (lnStartLine, lnEndLine, this.oPrefs.lMovelocals)
		This.lNoDotsInAssignments = .T.
		This.CreateNewLocals (lnStartLine, lnEndLine)
		lcLocalStatements = This.CreateLocalStatements()
		
		lcNewCode = ''
		For lnLoop = lnStartLine To lnEndLine
			lnLoopValueBefore = lnLoop
			lcSourceLine = This.GetSourceCodeLine (@lnLoop, , .T.)
			lcWord1 = Lower (Getwordnum (lcSourceLine,1))
			llAddTheseLines = .T.
			llInsertNewLocals = .F.
		
			Do Case
				Case Len (lcWord1) >= 4 And 'local ' = (lcWord1 + ' ')
					If This.oPrefs.lMoveLocals
						llAddTheseLines = .F.
						llInsertNewLocals = .T.
					Else
						llInsertLocalsLater = .T.
					Endif
		
				Case llInsertLocalsLater
					llInsertNewLocals = .T.
		
				Case Empty (lcSourceLine)
		
				Case lcWord1 = '#if'
					llInsertNewLocals = .T.
		
				Case Inlist (lcWord1, '*', '#', INLINECOMMENTS)
		
				Case Len (lcWord1) >= 4 And 			;
						('procedure ' 		= lcWord1 	;
						or 'function ' 		= lcWord1 	;
						or 'hidden ' 		= lcWord1 	;
						or 'protected ' 	= lcWord1 	;
						or 'lparameters ' 	= lcWord1 	;
						or 'parameters ' 	= lcWord1 	;
						or 'public ' 		= lcWord1 	;
						or 'private ' 		= lcWord1 	;
						or '*:global ' 		= lcWord1 	;
						)
		
				Otherwise
					llInsertNewLocals = .T.
		
			Endcase
		
			If llInsertNewLocals And Not Empty (lcLocalStatements)
				lcNewCode = Iif (Empty (lcNewCode), '', lcNewCode + LINEEND) + lcLocalStatements
				lcLocalStatements = ''
			Endif
		
			If llAddTheseLines
				For lnI = lnLoopValueBefore To lnLoop
					lcNewCode = Iif (Empty (lcNewCode), '', lcNewCode + LINEEND) + This.aCodeLines (lnI)
				Endfor
			Endif
		Endfor
		
		Return lcNewCode
		
	ENDPROC

	PROCEDURE fetchparameterslist
		Local lcCodeSource
		
		lcCodeSource = This.GetEditorWindowText (.T.)
		
		If Empty (lcCodeSource)
			Return .F.
		Endif
		
		Return This.GetParametersList (lcCodeSource)
		
		
	ENDPROC

	PROCEDURE findcurrentlocals
		Lparameters lnStartLoop, lnEndLoop, llMoveLocals
		Local laLocals[1], lcASPhrase, lcCurrentLocals, lcDims, lcName, lcSourceLine, lcType, lcWord1
		Local llFirstTimeThru, lnI, lnLoop
		
		lcCurrentLocals	= ','
		llFirstTimeThru	= .T.
		This.nLocalsList	= 0
		
		* Find the existing local declarations
		For lnLoop = lnStartLoop To lnEndLoop
			* Add SourceLine to previous if continuation line
			lcSourceLine = This.GetSourceCodeLine (@lnLoop, , .T.)
		
			lcSourceLine = IIf (Lower (Left (lcSourceLine, 7)) == 'hidden ', Alltrim (Substr (lcSourceLine, 8)), lcSourceLine)
			lcSourceLine = IIf (Lower (Left (lcSourceLine, 10)) == 'protected ', Alltrim (Substr (lcSourceLine, 11)), lcSourceLine)
		
			*--------------------------------------------------
			*  GLR 8-29-2006 : add Private, Public, and Dimension to the list of possible declaration statements
			*--------------------------------------------------
			*-- GLR 8/31/2006 : added 'Define' to list
			*-- THM 8/31/2006 : removed 'dimens' from list.
			lcWord1 = Lower (Getwordnum (lcSourceLine, 1))
			If Inlist (lcWord1, 'local', 'privat', 'public', 'parame', 'lparam', '*:glob',		;
					  'proced', 'functi', 'endpro', 'endfun', 'define')
				lcType = 'other'
				Do Case
						*--------------------------------------------------
						*  standard declarations
						*--------------------------------------------------
					Case 'local ' = lcWord1						;
							Or 'private ' = lcWord1				;
							Or 'public ' = lcWord1				;
							Or 'parameters ' = lcWord1			;
							Or 'lparameters ' = lcWord1			;
							Or '*:global ' = lcWord1
						lcType		 = lcWord1
						lcSourceLine = Substr (lcSourceLine, 1 + Len (lcWord1))
		
						If Lower (Getwordnum (lcSourceLine, 1)) == 'array'
							lcSourceLine = Alltrim (lcSourceLine)
							lcSourceLine = Substr (lcSourceLine, 7)
						Endif
						*--------------------------------------------------
						*  if start procedure, get arguments
						*--------------------------------------------------
					Case 'procedure ' = lcWord1 Or 'function ' = lcWord1
						lcSourceLine = Strtran(lcSourceLine, '()', '')
						Do Case
							Case Not llFirstTimeThru
								Exit
							Case '(' $ lcSourceLine
								lcType		 = 'lparameters'
								lcSourceLine = Strtran (Substr (lcSourceLine, At ('(', lcSourceLine) + 1), ')', '')
							Otherwise
								Loop
						Endcase
		
					Otherwise
						Loop
				Endcase
		
				*--------------------------------------------------
				*  Parse declarations
				*--------------------------------------------------
		
				If Not Empty (lcSourceLine)
					Dimension laLocals(1)
					This.ParseCodeLine (lcSourceLine, @laLocals, .F.)
		
					For lnI = 1 To IIf (Alen (laLocals) # 1, Alen (laLocals, 1), 0)
						lcName	   = Alltrim (laLocals (lnI, 1))
						lcDims	   = laLocals (lnI, 2)
						lcASPhrase = laLocals (lnI, 3)
		
						Do Case
							Case 'local ' = (lcWord1 + ' ') And llMoveLocals
								This.AddNewLocal (lcName, lcASPhrase, Not Empty (lcDims), .T., lcDims)
							Case Not Lower (',' + lcName + ',') $ Lower (lcCurrentLocals)
								lcCurrentLocals = lcCurrentLocals + lcName + ','
						Endcase
		
						This.nLocalsList = This.nLocalsList + 1
						Dimension This.aLocalsList (This.nLocalsList, 2)
						This.aLocalsList (This.nLocalsList, 1) = lcName
						This.aLocalsList (This.nLocalsList, 2) = lcType
		
					Endfor
				Endif
			Endif
			llFirstTimeThru = .F.
		Endfor
		
		Return lcCurrentLocals
		
	ENDPROC

	PROCEDURE findlocalslinenumber
		Lparameters lnStartLoop, llFirst
		Local lcSourceLine, lcWord1, lnLineNumber, lnLocalLineNumber, lnLoopValueBefore, lnLoop
		
		lnLineNumber = lnStartLoop
		lnLocalLineNumber = 100000
		
		For lnLoop = lnStartLoop To Alen (This.aCodeLines)
			lnLoopValueBefore = lnLoop
			lcSourceLine = This.GetSourceCodeLine (@lnLoop, , .T.)
			lcWord1 = Lower (Getwordnum (lcSourceLine,1))
		
			Do Case
				Case Empty (lcSourceLine)
					lnLineNumber = lnLoop
		
				Case Inlist (lcWord1, '*', '#', INLINECOMMENTS)
					lnLineNumber = lnLoop + 1
		
				Case Len (lcWord1) >= 4 And 'local ' = lcWord1
					Do Case
						Case llFirst
							Return lnLoopValueBefore 
						Case lnLineNumber <= lnLocalLineNumber
							lnLineNumber = lnLoop + 1
							lnLocalLineNumber = lnLineNumber
					Endcase
		
				Case Len (lcWord1) >= 4 And 			;
						('procedure ' = lcWord1 		;
						or 'function ' = lcWord1 		;
						or 'hidden ' = lcWord1 			;
						or 'protected ' = lcWord1 		;
						or 'lparameters ' = lcWord1 	;
						or 'parameters ' = lcWord1 		;
						or 'public ' = lcWord1 			;
						or 'private ' = lcWord1 		;
						or '*:global ' = lcWord1 		;
						)
					lnLineNumber = lnLoop + 1
		
				Otherwise
					Return Min (lnLineNumber, lnLocalLineNumber)
		
			Endcase
		Endfor
		
		Return lnLineNumber
		
	ENDPROC

	PROCEDURE findprocstartline
		Lparameters lnCurrentLine
		Local lcSourceLine, lcWord1, lcWord2, lnCounter, lnCounterNow, lnProcStart 
		
		lnProcStart = 1
		For lnCounter = 1 To lnCurrentLine
			lnCounterNow = lnCounter
			lcSourceLine = This.GetSourceCodeLine (@lnCounter)
			lcWord1 = Lower (Getwordnum (lcSourceLine,1))
			lcWord2 = Lower (Getwordnum (lcSourceLine,2))
		
			If Len (lcWord1) >= 4											;
					and ('procedure ' = lcWord1 or 'function ' = lcWord1)
				lnProcStart = lnCounterNow
			Endif
		
			If Len (lcWord1) >= 4											;
					and ('protected ' = lcWord1 or 'hidden ' = lcWord1)	;
					and Len (lcWord2) >= 4 									;
					and ('procedure ' = lcWord2 or 'function ' = lcWord2)
				lnProcStart = lnCounterNow
			Endif
		Endfor
		
		Return lnProcStart 
	ENDPROC

	PROCEDURE fixascolumn
		Lparameters lcLine, lnWordWidth, lnWITHColumn, lnAfterWITHColumn
		Local lcLeft, lcNewLeft, lcNewLine, lcRight, lnPos
		
		lcLeft = This.FindBeforeAS (lcLine)
		If 0 = Len (lcLeft)
			Return lcLine
		Endif
		
		lcRight = This.TrimLeadingWhiteSpace (Substr (lcLine, 1 + Len (lcLeft) + lnWordWidth))
		If Not Right (lcLine,1) ISABLANK
			lcLine = lcLine + ' '
		Endif
		
		lcNewLeft = This.AddWhiteSpace (lcLeft, lnWITHColumn) + Substr (lcLine, 1 + Len (lcLeft), lnWordWidth)
		lcNewLine = This.AddWhiteSpace (lcNewLeft, lnAfterWITHColumn) + lcRight
		
		Return lcNewLine
		
	ENDPROC

	PROCEDURE fixwith
		Lparameters lcLine, lnWordWidth, lnWITHColumn, lnAfterWITHColumn
		Local lcLeft, lcNewLeft, lcNewLine, lcRight, lnPos
		
		lnPos = 1 + At (' WITH ', Strtran (Upper (lcLine), Tab, ' ', 1, 999))
		
		If lnPos <= 1
			Return lcLine
		Endif
		
		lcLeft = Left (lcLine, lnPos - 1)
		lcRight = This.TrimLeadingWhiteSpace (Substr (lcLine, lnPos + lnWordWidth)) 
		
		lcNewLeft = This.AddWhiteSpace (lcLeft, lnWITHColumn) + Substr (lcLine, lnPos, lnWordWidth)
		lcNewLine = This.AddWhiteSpace (lcNewLeft, lnAfterWITHColumn) + lcRight
		
		Return lcNewLine
		
		
		
	ENDPROC

	PROCEDURE fixwithstatements
		Lparameters lcSourceLine
		
		Local lcWord1, lcWord2, lnJ, lnPos
		
		If Pcount() = 0
			With This
				.nWithEndWithLevel = 0
				.aWithEndWith = ' '
				.cCurrentWithEndWith = ''
			Endwith
			Return
		Endif
		
		lcWord1 = Upper (Getwordnum (lcSourceLine,1))
		
		Do Case
			Case lcWord1 == 'WITH'
				lcWord2 = Alltrim (Substr (Alltrim (lcSourceLine), 5))
				If lcWord2 = '.'
					lcWord2 = This.cCurrentWithEndWith + lcWord2
					lcSourceLine = 'With ' + lcWord2
				Endif
				This.nWithEndWithLevel = This.nWithEndWithLevel + 1
				Dimension This.aWithEndWith(This.nWithEndWithLevel)
				This.aWithEndWith(This.nWithEndWithLevel) = lcWord2
				This.cCurrentWithEndWith = lcWord2
		
			Case lcWord1 == 'ENDWITH'
				If This.nWithEndWithLevel > 1
					This.nWithEndWithLevel = This.nWithEndWithLevel - 1
					This.cCurrentWithEndWith = This.aWithEndWith(This.nWithEndWithLevel)
				Else
					This.nWithEndWithLevel = 0
					This.cCurrentWithEndWith = ''
				Endif
		
			Case Not Empty (This.cCurrentWithEndWith)
				lcSourceLine = ' ' + lcSourceLine
				For lnJ = 1 To 999
					lnPos = At (' .', lcSourceLine, lnJ)
					Do Case
						Case lnPos = 0
							Exit
						Case Isdigit (Substr (lcSourceLine, lnPos + 2, 1))
						Case Inlist (Upper (Substr (lcSourceLine, lnPos + 1)), '.T.', '.F.', '.NULL.')
						Otherwise
							lcSourceLine = Left (lcSourceLine, lnPos) + This.cCurrentWithEndWith + Substr (lcSourceLine, lnPos + 1)
							If This.cCurrentWithEndWith # '.'
								lnJ = lnJ - 1
							Endif
					Endcase
				Endfor
		Endcase
		
		Return lcSourceLine
		
	ENDPROC

	PROCEDURE formatidlist
	ENDPROC

	PROCEDURE getassignmentcol
		Lparameters lcLine
		Local lcLeft, lcLeftBracket, lcRightBracket, lcText, lnPos 
		
		lnPos = At ('=', lcLine)
		If lnPos = 0 Or Not This.oPrefs.lFixAssignments
			Return 0
		Endif
		
		lcLeft = This.TrimTrailingWhiteSpace (Left (lcLine, lnPos - 1))
		lcText = This.TrimLeadingWhiteSpace (lcLeft)
		
		* 02/22/2012 -- added to handle assignments of arrays
		If Right(lcText,1) $ '])'
			lcRightBracket = Right(lcText,1)
			lcLeftBracket = IIF(lcRightBracket = ']', '[', '(') 
			If Occurs(lcLeftBracket, lcText) = Occurs(lcRightBracket, lcText)
				lcText = This.TrimTrailingWhiteSpace (Left(lcText, At(lcLeftBracket, lcText) - 1)) 
			Endif
		Endif && Right(lcText,1) $ '])'
			
		If Len (lcText) # Len (Chrtran (lcText, Chrtran(NOTNAMECHARS, '&', '') + CR + LF, '')) or Empty (lcText)
			Return 0
		Endif
		
		Return This.CountCharacterWidth (lcLeft)
		
	ENDPROC

	PROCEDURE getconstants
		Lparameters lcSourceText, tcIncludeFileName
		
		Local lcIncludeFile, lcValue, lnI, loIncludeFiles, loRegExp, loResults
		
		*   #Defines
		loRegExp = This.oUtils.GetRegExp()
		With loRegExp
			.Pattern  = '^\s*#Defi(|n|ne)\s+\w+'
			loResults = .Execute (lcSourceText)
		Endwith
		
		For lnI = 0 To loResults.Count - 1
			lcValue  = Chrtran (loResults.Item (lnI).Value, Chr(13) + Chr(10), '')
			Insert Into crsr_IDs_Constants Values (Upper (Getwordnum (lcValue, 2)))
		Endfor
		
		*   #Includes
		loIncludeFiles = This.oUtils.GetIncludeFiles (lcSourceText)
		For Each lcIncludeFile In loIncludeFiles FoxObject
			If Empty (tcIncludeFileName)
				lcIncludeFile = Fullpath (lcIncludeFile)
			Else
				lcIncludeFile = Fullpath (lcIncludeFile, tcIncludeFileName)
			Endif
		
			If File (lcIncludeFile)
				This.GetConstants (Filetostr (lcIncludeFile), lcIncludeFile)
			Endif
		
		EndFor 
		
		
	ENDPROC

	PROCEDURE geteditorwindowtext
		Lparameters llAllText
		
		Local lcCodeSource, lnSelEnd, lnSelStart
		
		If 0 >= This.oEditorWin.FindWindow()
			Return ''
		Endif
		
		With This.oEditorWin
			lnSelStart = .GetSelStart()
			lnSelEnd   = .GetSelEnd()
			If llAllText Or lnSelStart = lnSelEnd
				lnSelStart = 0
				lnSelEnd   = .GetEnvironment(2)
			Endif
			lcCodeSource   = .GetString (lnSelStart, lnSelEnd - 1)
		Endwith
		
		This.nSelStart = lnSelStart
		This.nSelEnd   = lnSelEnd
		
		Return lcCodeSource
	ENDPROC

	PROCEDURE getindentation
		Lparameters lcText
		
		Return Left(lcText, Len(lcText) - Len(Ltrim(lcText, 1, ' ', Chr(9)))) 
		
	ENDPROC

	PROCEDURE getparameterslist
		Lparameters lcCodeSource
		
		Local lcName, lcResult, lcType, lnI
		
		Alines (This.aCodeLines, lcCodeSource + ' ')
		This.FindCurrentLocals(1, Alen (This.aCodeLines))
		
		lcResult = ''
		For lnI = 1 To This.nLocalslist
			lcName = This.aLocalslist (lnI, 1)
			lcType = This.aLocalslist (lnI, 2)
			If lcType = 'para' Or lcType = 'lpara'
				lcResult = lcResult + IIf (Empty (lcResult), '', ', ') + lcName
			Endif
		Endfor
		
		Return lcResult
		
	ENDPROC

	PROCEDURE getsourcecodeline
		Lparameters lnCounter, llIgnoreTextMerge, llIgnoreHashIF
		Local lcLine, lcSourceLine, llHashIFBlock, llTextBlock
		
		lcSourceLine  = ''
		llTextBlock	  = .F.
		llHashIFBlock = .F.
		Do While lnCounter <= Alen (This.aCodeLines)
			lcLine		 = This.aCodeLines (lnCounter)
			lcSourceLine = Evl (lcSourceLine + ' ', '') + Alltrim (Chrtran (lcLine, Tab + CR + LF, '   '))
			lnCounter	 = lnCounter + 1
		
			Do Case
				Case llTextBlock And Upper (Getwordnum (lcLine, 1)) == 'ENDTEXT'
					Exit
				Case llTextBlock
					Loop
				Case Upper (Getwordnum (lcLine, 1)) == 'TEXT'
					If llIgnoreTextMerge
						lnCounter = This.DoIDListText(lcSourceLine, lnCounter, Alen (This.aCodeLines))
						Exit
					Else
						llTextBlock = .T.
					Endif
					Loop
		
				Case llHashIFBlock And Upper (Getwordnum (lcLine, 1)) == '#ENDIF'
					Exit
				Case llHashIFBlock
					Loop
				Case llIgnoreHashIF And Upper (Getwordnum (lcLine, 1)) == '#IF'
					llHashIFBlock = .T.
					Loop
		
				Case ';' == Right (lcSourceLine, 1)
					Loop
				Case INLINECOMMENTS $ lcSourceLine
					lcSourceLine = Alltrim (Left (lcSourceLine, At (INLINECOMMENTS, lcSourceLine) - 1))
					If ';' = Right (lcSourceLine, 1)
						Loop
					Endif
			Endcase
		
			lnCounter = lnCounter - 1
			Exit
		
		Enddo
		Return lcSourceLine
		
	ENDPROC

	PROCEDURE getvariableslist
		Lparameters tcCodeSource, tcType
		
		Local laResult[1], lcKey, lcName, lcType, lcVarType, lnCount, lnI, lnRow, loResult
		
		Alines (This.aCodeLines, tcCodeSource + ' ')
		
		This.nNewLocalsCount = 0
		Dimension This.aNewlocals(1, 10)
		* This.aNewLocals:
		*    Col 1 = Local Name
		*    Col 2 = AS blabla
		*    Col 3 = Array?
		*    Col 4 = Col 2 non-empty
		*    Col 5 = Begins with lowercase 'l'
		*    Col 6 = Already found in LOCALs
		*    Col 7 = Array parameters
		*    Col 8 = Actual assignments
		*    Col 9 = <Unused>
		*    Col 10 = <Unused>
		
		This.FindCurrentLocals(1, Alen (This.aCodeLines))
		This.lNoDotsInAssignments = .T.
		This.CreateNewLocals (1, Alen (This.aCodeLines))
		
		lcType = Evl(tcType, 'PL!')
		
		Do Case
			Case '#' $ lcType
				loResult = Createobject('Empty')
				AddProperty(loResult, 'aList[1]')
				Acopy(This.aLocalsList, loResult.aList)
				Return loResult
			Case '*' $ lcType
				lnCount = Alen(This.aLocalsList, 1)
				Dimension laResult(lnCount, 3)
				For lnI = 1 To lnCount
					If not Empty(This.aLocalsList[lnI, 1])
						laResult[lnI, 1] = This.aLocalsList[lnI, 1]
						laResult[lnI, 2] = This.aLocalsList[lnI, 2]
					EndIf 
				Endfor
		
				lnCount = Alen(This.aNewlocals, 1)
				For lnI = 1 To lnCount
					lcName = This.aNewlocals[lnI, 1]
					If Empty(lcName)
						Loop
					EndIf 
					If (This.aNewlocals[lnI, 6] = .F.) Or (This.aNewlocals[lnI, 8] = .T.)
		
						lnRow = Ascan(laResult, lcName, 1, -1, 1, 15)
						If lnRow # 0
							laResult[lnRow, 3] = .T.
						Else
							lnRow = Alen(laResult, 1) + 1
							Dimension laResult[lnRow, 3]
							laResult[lnRow, 1] = lcName
							laResult[lnRow, 2] = '?'
							laResult[lnRow, 3] = .T.
						Endif && lnRow # 0
					Endif && This.aNewlocals[lnI,6]  or This.aNewlocals[lnI,8]
				Endfor
				loResult = Createobject('Empty')
				AddProperty(loResult, 'aList[1]')
				Acopy(laResult, loResult.aList)
				Return loResult
		Endcase
		
		loResult		 = Createobject('Collection')
		loResult.KeySort = 2
		For lnI = 1 To This.nLocalsList
			lcName	  = This.aLocalsList(lnI, 1)
			lcKey	  = Upper(lcName)
			lcVarType = This.aLocalsList(lnI, 2)
			If ('P' $ lcType And 'para' $ lcVarType)		;
					Or ('L' $ lcType And Inlist(lcVarType, 'local', 'private', 'public'))
				If 0 = loResult.GetKey(lcKey)
					loResult.Add(lcName, lcKey)
				Endif
			Endif
		Endfor
		
		If '!' $ lcType
			For lnI = 1 To This.nNewLocalsCount
				lcName = This.aNewlocals(lnI, 1)
				If Ascan(This.aLocalsList, lcName, 1, -1, 1, 15) # 0
					Loop
				Endif
				lcKey  = Upper(lcName)
				If 0 = loResult.GetKey(lcKey)
					loResult.Add(lcName, lcKey)
				Endif
			Endfor
		Endif
		
		If '=' $ lcType
			For lnI = 1 To This.nNewLocalsCount
				lcName = This.aNewlocals(lnI, 1)
				lcKey  = Upper(lcName)
				If 0 = loResult.GetKey(lcKey) And This.aNewlocals(lnI, 8)
					loResult.Add(lcName, lcKey)
				Endif
			Endfor
		Endif
		
		Return loResult
		
	ENDPROC

	PROCEDURE getwindowhandle
		Set Library To (Home() + "FoxTools.fll") Additive
		Return _WonTop ()
		
	ENDPROC

	HIDDEN PROCEDURE Init
		Lparameters loUtils, loPrefs, loEditorWin, lcSystemMemoryVariables
		
		Local lcDBF, lcPlugIn, loThor
		
		With This
			.oUtils					= loUtils
			.oPrefs					= loPrefs
			.oEditorWin				= loEditorWin
			.cSystemMemoryVariables	= lcSystemMemoryVariables
		Endwith
		
		If 'C' = Vartype (_Screen.cThorDispatcher)
			*!* * Removed 12/28/2012 / JRN
			*!* loThor			 = Execscript (_Screen.cThorDispatcher, 'Thor Engine=')
			*!* This.lAddMDots	 = Nvl(loThor.GetOption ('MDots in BeautifyX', 'MDots'), .F.)
			*!* This.nMDotsUsage = Nvl(loThor.GetOption ('MDots Usage', 'MDots'), 1)
			This.lAddMDots	 = This.GetThorOption('MDots in BeautifyX', 'MDots', .F.)
			This.nMDotsUsage = This.GetThorOption('MDots Usage', 'MDots', 1)
			This.lRETURNS    = This.GetThorOption('BeautifyX', 'RETURNs between WITH/ENDWITH', 1)
			This.lAddMDots	 = Not Empty(This.lAddMDots)
			This.lApplyCKL   = This.GetThorOption('ApplyCKL in BeautifyX', 'Apply Custom Keyword List to code window' , .F.)
			This.lAddtoCKL   = This.GetThorOption('AddtoCKL in BeautifyX', 'Add all words in code window' , .F.)
			This.lAutoAddtoCKL   = This.GetThorOption('AutoAddNewtoCKL in BeautifyX', 'Add all words in code window' , .F.)
		Endif
		
		If Not Used ('fdkeywrd')
			m.lcDBF = This.whereis ('FDKEYWRD.DBF')
			If Not File (m.lcDBF)
				Return .F.
			Endif
			Use (m.lcDBF) Order token Alias fdkeywrd In 0
		Endif
		
		lcPlugIn = This.oUtils.GetPlugInPath ('IsOperator')
		If Not Empty (lcPlugIn)
			This.cpluginisoperator = Filetostr (lcPlugIn)
		Endif
	ENDPROC

	PROCEDURE insertconstants
		Lparameters loConstants
		
		For each lcConstant in loConstants FoxObject
			This.InsertID(lcConstant, TYPE_Constants)
		EndFor 
		
	ENDPROC

	PROCEDURE insertid
		Lparameters lcWord, lnType
		
		Do Case
			Case Empty (lcWord)
		
			Case Left (lcWord, 1) $ ['^+(,0123456789)]
		
			Case lcWord = '&' And Not '.' $ lcWord
		
			Case lcWord = '.' And Isdigit (Substr (lcWord, 2, 1))
		
			Case Inlist (Upper (lcWord) + ' '		;
					  , '.T. ', '.F. ', '.OR. ', '.NOT. ', '.AND. ', '.NULL. ', '( ', '^ ')
		
				*Case This.IsKeyWord (Substr (lcWord, 1 + Rat ('.', lcWord)))
			Case This.IsKeyWord (lcWord)
		
			Otherwise
				Insert Into crsr_IDs_Refs Values (crsr_IDs_Procs.Id, crsr_IDs_Lines.Id, lcWord, lnType)
				Replace AnyFound With .T. In crsr_IDs_Lines
		
		Endcase
		
	ENDPROC

	PROCEDURE insertidothers
		Lparameters lcWord, lcNextWord
		
		Local llAssign, lnType
		
		llAssign = 0 # Ascan (This.aNewlocals, lcWord, 1, -1, 1, 15)
		Do Case
		
			Case lcNextWord = '('
				If '.' $ lcWord
					lnType = TYPE_Methods
				Else
					lnType = TYPE_Procedures
				Endif
		
			Case llAssign And Not '.' $ lcWord
				lnType = TYPE_Assignments
			Case llAssign
				lnType = TYPE_PropAssign
			Case '.' $ lcWord
				lnType = TYPE_Objects
			Case This.lFieldReference 
				lnType = TYPE_Fields
			Otherwise
				lnType = TYPE_Others
		Endcase
		
		If Upper (lcWord) = 'M.'
			lcWord = Substr (lcWord, 3)
			lnType = TYPE_Others
		Endif
		
		This.InsertID (lcWord, lnType)
		
	ENDPROC

	PROCEDURE insertlocalids
		Lparameters lcNewCode, lnType, lnStartWord
		
		Local lcWord2, lnI
		For lnI = lnStartWord To Getwordcount (lcNewCode)
			lcWord2		= Getwordnum (lcNewCode, lnI)
			If Upper (lcWord2) == 'AS' Or Upper (lcWord2) == 'OF'
				lnI = lnI + 1
			Endif
			This.InsertID (lcWord2, lnType)
		Endfor
		
	ENDPROC

	PROCEDURE iskeyword
		Lparameters lcWord
		
		Return Indexseek (Upper (lcWord) + ' ', .F., 'FDKEYWRD')
	ENDPROC

	PROCEDURE movelocalstotop
		Lparameters lnHandle, lnProcStart
		
		Local laLocals(1), laOthers(1)
		Local lcLine, lcNewCode, lcOldClipText, lcSourceLine, lcWord1, lnDestIndex, lnEndPosPos, lnI
		Local lnInsertLineNumber, lnLocalsCount, lnLoop, lnLoopNow, lnOthersCount, lnStartPos
		
		lnLocalsCount = 0
		lnOthersCount = 0
		
		lnInsertLineNumber = This.FindLocalsLineNumber (lnProcStart, .T.)
		
		* Find the existing local declarations
		For lnLoop = lnInsertLineNumber To Alen (This.aCodeLines)
			lnLoopNow = lnLoop
			lcSourceLine = This.GetSourceCodeLine (@lnLoop, , .T.)
		
			lcSourceLine = IIf (Lower (Left (lcSourceLine, 7)) == 'hidden ', Alltrim (Substr (lcSourceLine, 8)), lcSourceLine)
			lcSourceLine = IIf (Lower (Left (lcSourceLine, 10)) == 'protected ', Alltrim (Substr (lcSourceLine, 11)), lcSourceLine)
		
			lcWord1 = Lower (Getwordnum (lcSourceLine,1))
		
			Do Case
				Case Len (lcWord1) >= 4 And 'local ' = lcWord1
					For lnI = lnLoopNow To lnLoop
						lnLocalsCount = lnLocalsCount + 1
						Dimension laLocals (lnLocalsCount)
						laLocals (lnLocalsCount) = This.aCodeLines (lnI)
					Endfor
		
				Case Len (lcWord1) >= 4 And (				;
						'procedure ' = lcWord1  			;
						or 'function ' = lcWord1  			;
						or 'endproc ' = lcWord1 			;
						Or 'endfunc ' = lcWord1)
					Exit
		
				Case Left (Lower (lcSourceLine), 13) == 'define class '
					Exit
		
				Otherwise
					For lnI = lnLoopNow To Min (lnLoop, Alen (This.aCodeLines)) 
						lnOthersCount = lnOthersCount + 1
						Dimension laOthers (lnOthersCount)
						laOthers (lnOthersCount) = This.aCodeLines (lnI)
					Endfor
		
			Endcase
		
		Endfor
		
		If lnLocalsCount = 0
			Return lnInsertLineNumber
		Endif
		
		lnDestIndex = lnInsertLineNumber
		lcNewCode = ''
		*!*	For lnI = 1 To lnLocalsCount
		*!*		lcLine = laLocals (lnI)
		*!*		This.aCodeLines (lnDestIndex) = lcLine
		*!*		lnDestIndex = lnDestIndex + 1
		*!*		lcNewCode = lcNewCode + lcLine + LINEEND
		*!*	Endfor
		
		For lnI = 1 To lnOthersCount
			lcLine = laOthers (lnI)
			This.aCodeLines (lnDestIndex) = lcLine
			lnDestIndex = lnDestIndex + 1
			lcNewCode = lcNewCode + lcLine + LINEEND
		Endfor
		
		lnStartPos = _EdGetLPos(lnHandle, lnInsertLineNumber - 1)
		lnEndPosPos = _EdGetLPos(lnHandle, lnLocalsCount + lnDestIndex - 1)
		_EdSelect (lnHandle, lnStartPos, lnEndPosPos)
		
		lcOldClipText = _Cliptext
		_Cliptext = lcNewCode
		_EdPaste (lnHandle)
		_Cliptext = lcOldClipText
		
		_EdSelect (lnHandle, lnStartPos, lnStartPos)
		_EdSetPos (lnHandle, lnStartPos)
		_EdStoPos (lnHandle, lnStartPos, .T.)
		
		Return lnInsertLineNumber
	ENDPROC

	PROCEDURE nativebeautify
		Lparameters lcSourceCode, llSkipIndentation
		
		This.SetBeautifyOptions()
		lcOptions = This.cBeautifyOptions 
		
		*** JRN 2010-05-09 : conditionally turn off indentation (for SELECT statements)
		If llSkipIndentation
			lcOptions = Stuff (lcOptions, 13, 1, Chr(0)) 
		EndIf 
		
		If "O" # Vartype (This.oBeautify)
			This.oNativeBeautify = peme_newsessionobject("cbeautify", "peme_beautifycode.vcx")
		EndIf 
		
		lcNewCode = lcSourceCode
		This.oNativeBeautify.Execute (@lcNewCode, lcOptions, 3, '')
		
		Return lcNewCode
		
	ENDPROC

	PROCEDURE parsecodeline
		* Parses a single code line into an array:
		*    Col 1 = Name
		*    Col 2 = Array Dimensions, if any
		*    Col 3 = AS phrase
		
		* All this tomfoolery because of confusion with commas:  they are separators between names
		* and also between dimensions of a name.
		* For example:
		* 	Dimension laResult[ALEN (laResult, 1) + 1], laTemp(3)
		
		Lparameters tcCodeLine, laResult, llAssignment
		
		#Define FILLER Chr(31)
		Local laExtras(1), lcArrayDims, lcChar, lcCode, lcMatchChar, lcName, lnDepth, lnExtraCounter, lnExtras, lnI
		Local lnMatchPos, lnPos
		
		lcCode = Chrtran (tcCodeLine, ';', ' ')
		lnExtras = 0
		
		Do While '(' $ lcCode Or '[' $ lcCode
			lnPos = Min (This.ATNew('(', lcCode), This.ATNew('[', lcCode))
			lcChar = Substr(lcCode, lnPos, 1)
			lcMatchChar = Iif (lcChar ='(', ')', ']')
			lnDepth = 1
			Do While .T.
				lnMatchPos = At (lcMatchChar, lcCode, lnDepth)
				lnMatchPos = Evl (lnMatchPos, 1 + Len (lcCode))
				If 0 = At (lcChar, Left (lcCode, lnMatchPos), lnDepth + 1)
					lnExtras = lnExtras + 1
					Dimension laExtras (lnExtras, 2)
					laExtras (lnExtras, 1) = Alltrim (Substr (Left (lcCode, lnMatchPos - 1), lnPos + 1))
					laExtras (lnExtras, 2) = Alltrim (Substr (Left (lcCode, lnMatchPos), lnPos))
					lcCode = Stuff (lcCode, lnPos, 1 + lnMatchPos - lnPos, FILLER)
					Exit
				Else
					lnDepth = lnDepth + 1
				Endif
			Enddo
		Enddo
		
		lnExtraCounter = 0
		For lnI = 1 To 1000
			lcName = Getwordnum (lcCode, lnI, ',')
			If Empty (lcName)
				Exit
			Endif
		
			Dimension laResult (lnI, 3)
		
			If ' as ' $ Lower (lcName)
				lnPos = At (' as ' , Lower (lcName))
				lcAsPhrase = Alltrim (Substr (lcName, lnPos + 4))
				lcName = Alltrim (Left (lcName, lnPos))
			Else
				lcAsPhrase = ''
			Endif
		
			If FILLER $ lcName
				lnExtraCounter = lnExtraCounter + 1
				lcArrayDims = laExtras [lnExtraCounter, 1]
				laResult (lnI, 1) = Strtran (lcName, FILLER, '')
				laResult (lnI, 2) = lcArrayDims
			Else
				laResult (lnI, 1) = lcName
				laResult (lnI, 2) = ''
			Endif
		
			If FILLER $ lcAsPhrase
				lnExtraCounter = lnExtraCounter + 1
				lcAsPhrase = laExtras [lnExtraCounter, 2]
			Endif
			laResult (lnI, 3) = lcAsPhrase
		Endfor
		
	ENDPROC

	PROCEDURE parselineforidlist
		* Parse a single line of code (that is, a line including continuation lines, with ; removed
		*      (1) WITH/ENDWITH ... replace names beginning with dot with the WITH that precedes them
		*      (2) Character constants are replaced with '^' (for historical reasons .. s.b. ')
		*      (3) All other none-name characters with '+'
		
		Lparameters lcSourceLine, lcNotNameChars
		
		Local lcNewCode, lcRestLineString, lcThisChar, lnCharPos, lnClosingCharPosition
		
		lcSourceLine = This.FixWithStatements (lcSourceLine)
		lcSourceLine = Strtran (lcSourceLine, '.*', ' ')
		
		lcNewCode = ''
		For lnCharPos = 1 To Len (lcSourceLine)
			lcThisChar = Substr (lcSourceLine, lnCharPos, 1)
			Do Case
				Case lcThisChar $ ' ' + TAB
					lcThisChar = ' '
				Case lcThisChar $ ['"{] Or		;
						(lcThisChar = '[' And Not This.IsNameChar (Right (This.TrimTrailingWhiteSpace (lcNewCode), 1)))
					lcRestLineString	  = Substr (lcSourceLine, lnCharPos + 1)
					lnClosingCharPosition = At (IIf (lcThisChar = '[', ']', IIf (lcThisChar = '{', '}', lcThisChar)), lcRestLineString)
					lnCharPos			  = lnCharPos + lnClosingCharPosition
					lcThisChar			  = [ ^ ]
				Case lcThisChar = ';'
					lcThisChar = ' '
				Case lcThisChar $ lcNotNameChars + '^'
					lcThisChar = ' + '
				Case lcThisChar $ '(),+'
					lcThisChar = ' ' + lcThisChar + ' '
			Endcase
			lcNewCode = lcNewCode + lcThisChar
		Endfor
		
		Return lcNewCode
	ENDPROC

	PROCEDURE parseprgcodeblocks
		Local lcClassName, lcName, lcSourceLine, lcWord1, lcWord2, lcWord3, lnCount, lnCounterNow, lnCurrentRow
		Local lnLineCount
		
		lnCurrentRow = 1
		Dimension This.aPRGCodeBlocks (lnCurrentRow, 4)
		This.aPRGCodeBlocks (lnCurrentRow, 1) = ''
		This.aPRGCodeBlocks (lnCurrentRow, 2) = 'P'
		This.aPRGCodeBlocks (lnCurrentRow, 3) = 1
		This.aPRGCodeBlocks (lnCurrentRow, 4) = 1
		
		lnLineCount	= Alen (This.aCodeLines)
		lcClassName	= ''
		
		For lnCount = 1 To lnLineCount
			lnCounterNow = lnCount
			lcSourceLine = This.GetSourceCodeLine (@lnCount)
			lcWord1 = Lower (Getwordnum (lcSourceLine,1))
			lcWord2 = Lower (Getwordnum (lcSourceLine,2))
			lcWord3 = Lower (Getwordnum (lcSourceLine,3))
		
			Do Case
				Case Empty (lcSourceLine)
		
				Case Len (lcWord1) >= 4											;
						and ('procedure ' = lcWord1 Or 'function ' = lcWord1)
					If lnCounterNow > 1
						This.aPRGCodeBlocks(lnCurrentRow, 4) = lnCounterNow - 1
						lnCurrentRow = lnCurrentRow + 1
						Dimension This.aPRGCodeBlocks (lnCurrentRow, 4)
					Endif
					lcName = Getwordnum (lcSourceLine,2)
					If '(' $ lcName
						lcName = Left (lcName, At('(', lcName) - 1)
					Endif
					This.aPRGCodeBlocks (lnCurrentRow, 1) = lcClassName + lcName
					This.aPRGCodeBlocks (lnCurrentRow, 2) = Upper (Left (lcWord1,1))
					This.aPRGCodeBlocks (lnCurrentRow, 3) = lnCounterNow
					This.aPRGCodeBlocks (lnCurrentRow, 4) = lnCounterNow
		
				Case Len (lcWord1) >= 4											;
						and ('protected ' = lcWord1 Or 'hidden ' = lcWord1)	;
						and Len (lcWord2) >= 4 									;
						and ('procedure ' = lcWord2 Or 'function ' = lcWord2)
					If lnCounterNow > 1
						This.aPRGCodeBlocks(lnCurrentRow, 4) = lnCounterNow - 1
						lnCurrentRow = lnCurrentRow + 1
						Dimension This.aPRGCodeBlocks (lnCurrentRow, 4)
					Endif
					lcName = Getwordnum (lcSourceLine,3)
					If '(' $ lcName
						lcName = Left (lcName, At('(', lcName) - 1)
					Endif
					This.aPRGCodeBlocks (lnCurrentRow, 1) = lcClassName + lcName
					This.aPRGCodeBlocks (lnCurrentRow, 2) = Upper (Left (lcWord2,1))
					This.aPRGCodeBlocks (lnCurrentRow, 3) = lnCounterNow
					This.aPRGCodeBlocks (lnCurrentRow, 4) = lnCounterNow
		
				Case Len (lcWord1) >= 4											;
						and ('define ' = lcWord1)	;
						and Len (lcWord2) >= 4 									;
						and ('class ' = lcWord2)
					If lnCounterNow > 1
						This.aPRGCodeBlocks(lnCurrentRow, 4) = lnCounterNow - 1
						lnCurrentRow = lnCurrentRow + 1
						Dimension This.aPRGCodeBlocks (lnCurrentRow, 4)
					Endif
					This.aPRGCodeBlocks (lnCurrentRow, 1) = Getwordnum (lcSourceLine,3)
					This.aPRGCodeBlocks (lnCurrentRow, 2) = 'C'
					This.aPRGCodeBlocks (lnCurrentRow, 3) = lnCounterNow
					This.aPRGCodeBlocks (lnCurrentRow, 4) = lnCounterNow
					lcClassName	= This.aPRGCodeBlocks (lnCurrentRow, 1) + '.'
		
				Case Len (lcWord1) >= 4											;
						and ('enddefine ' = lcWord1   ;
						or 'endproc ' = lcWord1   ;
						or 'endfunc ' = lcWord1   ;
						)
					If lnCounterNow > 1
						This.aPRGCodeBlocks(lnCurrentRow, 4) = lnCounterNow
						lnCurrentRow = lnCurrentRow + 1
						Dimension This.aPRGCodeBlocks (lnCurrentRow, 4)
					Endif
					This.aPRGCodeBlocks (lnCurrentRow, 1) = ''
					This.aPRGCodeBlocks (lnCurrentRow, 2) = ' '
					This.aPRGCodeBlocks (lnCurrentRow, 3) = lnCounterNow + 1
					This.aPRGCodeBlocks (lnCurrentRow, 4) = lnCounterNow + 1
					If 'enddefine ' = lcWord1
						lcClassName	= ''
					EndIf 
		
			Endcase
		Endfor
		
		This.aPRGCodeBlocks (lnCurrentRow, 4) = lnLineCount
		
	ENDPROC

	PROCEDURE peme_beautify
		Local laEnv[25]
		Local lcCodeSource, lcIndent, lcNewCode, lcOldClipText, lcPrompt, llAnyOptions, llLocalsAllProcs
		Local llSelectedText, lnCurrentLine, lnHandle, lnOriginalCursor, lnResult, lnSelEnd, lnSelStart
		Local lnThisLine
		
		With This.oPrefs
			llAnyOptions = .lSettingsChanged	;
				or .lNativeBeautify 			;
				or .lBeautifyLocals 			;
				or .lFixAssignments				;
				or .lAlignSemicolons			;
				or .nSelectIndentation = 3 		;
				or .nParenIndent       # 2 		;
				or .nBeforeLeftParens  # 1		;
				or .nStringDelimiters  # 1		;
				or .nDefinitionForNOT  # 1		;
				or .nDefinitionForNOTEQUAL # 1
		Endwith
		
		If Not llAnyOptions
			Text to lcPrompt NoShow
		BeautifyX has not been activated yet. By default, none of its settings are activated.
		
		Do you want to be taken to the settings form?
			EndText
			If MESSAGEBOX(lcPrompt, 68, "BeautifyX not activated.", 0) = 6
				ExecScript(_Screen.cThorDispatcher, 'Thor_Proc_OpenOptionsPage', 'BeautifyX')
			EndIf
			Return
		Endif
		
		* Get the whandle for the current window
		lnHandle = This.GetWindowHandle()
		lnResult = _EdGetEnv (lnHandle, @laEnv )
		If (lnResult = 0 Or laEnv[25] = 0)
			Return ''
		Endif
		
		* Get the current cursor position
		lcOldClipText = _Cliptext
		
		This.SetBeautifyOptions()
		
		lnSelStart		 = laEnv[17]
		lnSelEnd		 = laEnv[18]
		lnOriginalCursor = laEnv[17]
		lnCurrentLine	 = _EdGetLNum (lnHandle, lnSelStart)
		This.nTabWidth	 = laEnv[21]
		If lnSelStart = lnSelEnd && if nothing highlighted, select all
			_EdSelect (lnHandle, 0, 1000000)
			lnResult   = _EdGetEnv (lnHandle, @laEnv )
			lnSelStart = laEnv[17]
			lnSelEnd   = laEnv[18]
			llLocalsAllProcs = This.oPrefs.lLocalsAllProcs
			llSelectedText = .F.
		Else
			llLocalsAllProcs = .T.
			llSelectedText = .T.
		Endif
		
		lcCodeSource = _EdGetStr (lnHandle, lnSelStart, lnSelEnd - 1)
		lcIndent = This.GetIndentation(lcCodeSource)
		
		****************************************************************
		****************************************************************
		
		If This.oPrefs.lBeautifyLocals
			lcCodeSource = This.CreateLocalsForCodeBlock(lcCodeSource, laEnv[25], lnCurrentLine, llLocalsAllProcs)
		Endif
		
		lcNewCode = This.BeautifyCodeBlock (lcCodeSource)
		
		If llSelectedText
			If Len(lcIndent) # 0
				lcNewCode = Iif(lcNewCode # lcIndent, lcIndent, ' ') + Strtran(lcNewCode, LINEEND, LINEEND + lcIndent, 1, 1000, 3)
			Endif
		Endif
		
		If Right (lcCodeSource, 1) $ LINEEND
			lcNewCode = lcNewCode + LINEEND
		Endif
		
		****************************************************************
		****************************************************************
		
		_Cliptext = lcNewCode
		_EdPaste (lnHandle)
		
		If this.lRETURNS 
			_WSelect(lnHandle)
			If ExecScript(_screen.Cthordispatcher, 'Thor_Proc_CheckWindowForReturns', 2) && prompt if any found
				_Cliptext = lcOldClipText
				Return
			EndIf 
		EndIf 
		
		* Try to go back to where we started
		lnThisLine = _EdGetLPos (lnHandle, lnCurrentLine)
		_EdSelect (lnHandle, lnThisLine, lnThisLine)
		_EdSetPos (lnHandle, lnThisLine)
		_EdStoPos (lnHandle, lnThisLine, .T.)
		
		_Cliptext = lcOldClipText
		
		
	ENDPROC

	PROCEDURE peme_createidlist
		Lparameters llAllText
		
		Local loFormIDList As 'FrmIDList' Of  'Source\EditProperty.VCX'
		Local lcCodeSource, lcInclude, lcName, lcPRGTitle, lcType, lnBlocks, lnEnd, lnEndByte, lnI, lnLines
		Local lnStart, lnStartByte, lnStartLine, loProcs
		
		lcCodeSource = This.GetEditorWindowText(llAllText)
		
		If Empty (lcCodeSource)
			Return .F.
		Endif
		
		This.CreateIDListCursors()
		This.GetConstants (lcCodeSource)
		
		* for a single method
		If This.oEditorWin.GetEnvironment(25) = 10
		
			Alines (This.aCodeLines, lcCodeSource)
			Insert Into crsr_IDs_Procs (StartLine) Values (1)
			This.CreateIDList ('', 1, Alen (This.aCodeLines))
			lcInclude	 = This.oUtils.GetCurrentIncludeFile()
			If File (lcInclude)
				This.GetConstants (Filetostr (lcInclude), lcInclude)
			Endif
		
		Else
		
			* or a PRG with no embedded PROCs or FUNCs
			loProcs	   = This.oUtils.GetProcedureStartPositions (lcCodeSource)
		
			If 0 = loProcs.Count
		
				Alines (This.aCodeLines, lcCodeSource)
				Insert Into crsr_IDs_Procs (StartLine) Values (1)
				This.CreateIDList ('', 1, Alen (This.aCodeLines))
		
			Else
		
				lnStartLine = 1
				* for a PRG with PROCs and FUNCs
				For lnI = 0 To loProcs.Count
					Do Case
						Case lnI = 0
							lnStartByte	= 0
							lnEndByte	= loProcs(1).StartByte
							If lnEndByte = 0
								Loop
							Endif
							lcName = This.oEditorWin.GetTitle()
							lcType = 'Procedure'
						Case lnI < loProcs.Count
							lcName		= loProcs (lnI).Name
							lnStartByte	= loProcs (lnI).StartByte
							lnEndByte	= loProcs (lnI + 1).StartByte
							lcType		= loProcs (lnI).Type
						Otherwise
							lcName		= loProcs (lnI).Name
							lnStartByte	= loProcs (lnI).StartByte
							lnEndByte	= This.oEditorWin.GetEnvironment(2)
							lcType		= loProcs (lnI).Type
					Endcase
		
					lnLines = Alines (This.aCodeLines, Substr (lcCodeSource, lnStartByte + 1, lnEndByte - lnStartByte)) 
					If Inlist (lcType, 'Procedure', 'Method')
						Insert Into crsr_IDs_Procs (ProcName, StartLine) Values (lcName, lnStartLine)
						This.CreateIDList (lcName, 1, lnLines)
					Endif
					lnStartLine = lnStartLine + lnLines
				Endfor
		
			Endif
		
		Endif
		
		This.DoFormIDList (This.oEditorWin.nHandle)
		
	ENDPROC

	PROCEDURE peme_createlocals
		Local laEnv[25]
		Local lcCodeSource, lcIndent, lcNewCode, lcOldClipText, llLocalsAllProcs, llSelectedText, lnCurrentLine
		Local lnHandle, lnOriginalCursor, lnResult, lnSelEnd, lnSelStart, lnThisLine
		
		* Get the whandle for the current window
		lnHandle = This.GetWindowHandle()
		lnResult = _EdGetEnv (lnHandle, @laEnv )
		If (lnResult = 0 Or laEnv[25] = 0)
			Return ''
		Endif
		
		* Get the current cursor position
		lcOldClipText = _Cliptext
		
		This.SetBeautifyOptions()
		
		lnSelStart		 = laEnv[17]
		lnSelEnd		 = laEnv[18]
		lnOriginalCursor = laEnv[17]
		lnCurrentLine	 = _EdGetLNum (lnHandle, lnSelStart)
		This.nTabWidth	 = laEnv[21]
		If lnSelStart = lnSelEnd && if nothing highlighted, select all
			_EdSelect (lnHandle, 0, 1000000)
			lnResult   = _EdGetEnv (lnHandle, @laEnv )
			lnSelStart = laEnv[17]
			lnSelEnd   = laEnv[18]
			llLocalsAllProcs = This.oPrefs.lLocalsAllProcs
			llSelectedText = .F.
		Else
			llLocalsAllProcs = .T.
			llSelectedText = .T.
		Endif
		
		lcCodeSource = _EdGetStr (lnHandle, lnSelStart, lnSelEnd - 1)
		
		****************************************************************
		****************************************************************
		
		lcNewCode = This.CreateLocalsForCodeBlock(lcCodeSource, laEnv[25], lnCurrentLine, llLocalsAllProcs)
		
		If llSelectedText
			lcIndent = This.GetIndentation(lcCodeSource)
			If Len(lcIndent) # 0
				lcNewCode = Iif(lcNewCode # lcIndent, lcIndent, ' ') + Strtran(lcNewCode, LINEEND + 'L', LINEEND + lcIndent + 'L', 1, 1000, 3)
			Endif
		Endif
		
		****************************************************************
		****************************************************************
		
		_Cliptext = lcNewCode
		_EdPaste (lnHandle)
		
		* Try to go back to where we started
		lnThisLine = _EdGetLPos (lnHandle, lnCurrentLine)
		_EdSelect (lnHandle, lnThisLine, lnThisLine)
		_EdSetPos (lnHandle, lnThisLine)
		_EdStoPos (lnHandle, lnThisLine, .T.)
		
		_Cliptext = lcOldClipText
		
	ENDPROC

	PROCEDURE peme_createobjectidlist
		Lparameters loObject, llRecursive, lcSourceFileName, lcClassName
		Local lcIncludeFile
		
		With This
			.CreateIDListCursors()
		
			lcIncludeFile = This.oUtils.GetCurrentIncludeFile()
			If Not Empty (lcIncludeFile)
				.GetConstants (Filetostr (lcIncludeFile), lcIncludeFile)
			Endif
		
			.AddObjectIDList (loObject, llRecursive)
		
		Endwith
		
		If Lower (loObject.BaseClass) == 'form'
			Select  Distinct Id							;
				From crsr_IDs_Procs						;
				Where 1 = Occurs ('.', ProcName)		;
				Into Cursor crsr_ThisForm_IDs
			Index on ID tag ID 
		
			Select crsr_IDs_Refs
			Set Relation To ProcID Into crsr_ThisForm_IDs
		
			Replace	Name  With	'Thisform.' + Substr (Name, 6)		;
				For Found ('crsr_ThisForm_IDs')						;
					And Upper (Left (Name, 5)) == 'THIS.'
		
		Endif
		
		This.DoFormIDList(0, lcSourceFileName, lcClassName)
		
	ENDPROC

	PROCEDURE regexpsearch
		Lparameters tcPattern, tcText
		This.oRegExp.Pattern = tcPattern
		Return This.oRegExp.Execute (tcText)
		
		
	ENDPROC

	PROCEDURE removeparens
		Lparameters lcText
		
		Local lcThisChar, lnEndPos, lnStartPos 
		lcText = Chrtran(lcText, '()', '[]')
		Do While .T.
			lnStartPos = Min (This.AtNew(['], lcText), This.AtNew(["], lcText), This.AtNew(']', lcText))
			If lnStartPos > Len(lcText)
				Return lcText
			Endif
		
			lcThisChar = Substr (lcText, lnStartPos, 1)
			If lcThisChar $ ['"]
				lnEndPos = This.AtNew(lcThisChar, lcText, 2)
				lcText	 = Left (lcText, lnStartPos - 1) + ' ' + Substr (lcText, lnEndPos + 1)
			Else
				lnEndPos   = lnStartPos
				lnStartPos = Rat('[', Left(lcText, lnEndPos))
				lcText	   = Left (lcText, lnStartPos - 1) + '( ' + Substr (lcText, lnEndPos + 1)
			Endif
		Enddo && While .T.
	ENDPROC

	PROCEDURE setbeautifyoptions
		*    Options:
		*        1 = Variable case - 4 = no change, 3 = use 1st
		*        2 = command Case - 3 = mixed, 2 = lower, 1 = upper
		*        3 = number of spaces if option 4 (below) is 2
		*        4 = tabs/spaces, 						1 - use tabs, 2 - use spaces, 3 = no change
		*        5 =  ??
		*        6 = comments - 						1 = include comments, 0 = no
		*        7 = Line continuation 					1 = include, 0 = no
		*        8 = Extra indent beneath procedures 	1 = yes, 0 = no
		*        9 = Extra indent beneath Do Case 		1 = yes, 0 = no
		
		Local lcOptions, lnI, lnSelect
		
		lnSelect = Select()
		Select 0
		
		lcOptions =								 ;
			Chr(3) + Chr(0) + Chr(0) + Chr(0) +	 ;
			Chr(3) + Chr(0) + Chr(0) + Chr(0) +	 ;
			Chr(4) + Chr(0) + Chr(0) + Chr(0) +	 ;
			Chr(1) + Chr(0) + Chr(0) + Chr(0) +	 ;
			Chr(0) + Chr(0) + Chr(0) + Chr(0) +	 ;
			Chr(0) + Chr(0) + Chr(0) + Chr(0) +	 ;
			Chr(1) + Chr(0) + Chr(0) + Chr(0) +	 ;
			Chr(0) + Chr(0) + Chr(0) + Chr(0) +	 ;
			Chr(0) + Chr(0) + Chr(0) + Chr(0)
		
		If Set ('Resource') = 'ON'
			Use (Set ('Resource', 1)) Again Shared Alias Resource
			Locate For Id = 'BEAUTIFY'
			If Found()
				lcOptions = Right (Data, 36)
			Endif
			Use
		Endif
		
		For lnI = 1 To 9
			This.nBeautifyOptions (lnI) = Asc (Substr (lcOptions, (4 * lnI) - 3, 1))
		Endfor
		
		Select (lnSelect)
		
		This.cBeautifyOptions = lcOptions
		
	ENDPROC

	PROCEDURE whereis
		Lparameters mfile
		Local mtemp
		
		If File (m.mfile)
			Return m.mfile
		Endif
		
		mtemp = 'fd3fll\' + m.mfile
		If File (m.mtemp)
			Return m.mtemp
		Endif
		
		mtemp = Sys(2004) + m.mfile
		If File (m.mtemp)
			Return m.mtemp
		Endif
		
		mtemp = Sys(2004) + 'wizards\' + m.mfile
		If File (m.mtemp)
			Return m.mtemp
		Endif
		
		Return ''
		
	ENDPROC

ENDDEFINE
